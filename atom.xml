<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FinLab 量化實驗室</title>
  
  <subtitle>回測與選股教學部落格</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.finlab.tw/"/>
  <updated>2019-03-09T13:17:45.370Z</updated>
  <id>https://www.finlab.tw/</id>
  
  <author>
    <name>koreal6803</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python新手教學(7)：策略優化</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E7%AD%96%E7%95%A5%E5%84%AA%E5%8C%96/"/>
    <id>https://www.finlab.tw/Python新手教學：策略優化/</id>
    <published>2019-02-25T08:04:20.000Z</published>
    <updated>2019-03-09T13:17:45.370Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，帶大家寫了一個簡單的策略，<br>然而，在現實生活中並沒有這麼管用，20年才賺三倍！？</p><p>所以這篇文章將帶介紹如何利用修改參數，來調整策略，進而達到更好的績效<br>但是人工調整參數很浪費時間，所以我們先使用簡單暴力法，來調整參數試試看。</p><p>成果如下：</p><center><img src="/Python新手教學：策略優化/result.png" title="最終成果2"></center><h3 id="先回顧上次的策略"><a href="#先回顧上次的策略" class="headerlink" title="先回顧上次的策略"></a>先回顧上次的策略</h3><p>由於這是系列文章，要完成到上次的步驟其實有點煩瑣，<br>所以這邊就簡單的前情提要一下<br>總共有三個步驟：</p><ol><li>下載台股大盤資料</li><li>編寫台股的sharpe ratio</li><li>利用sharpe ratio製作回測</li></ol><p>這邊就不厭其煩的先把上次的code拿來，方便大家直接複製貼上</p><h3 id="1-下載台股大盤資料"><a href="#1-下載台股大盤資料" class="headerlink" title="1. 下載台股大盤資料"></a>1. 下載台股大盤資料</h3><p>以下這段程式，已經於「<a href="/Python新手教學2全球指數一次抓/">全球指數一次抓</a>」講過了，<br>假如想瞭解的話，可以去爬個文，這邊就不贅述了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line">    now = int(datetime.datetime.now().timestamp())+<span class="number">86400</span></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/"</span> + stock_id + <span class="string">"?period1=0&amp;period2="</span> + str(now) + <span class="string">"&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    response = requests.post(url)</span><br><span class="line"></span><br><span class="line">    f = io.StringIO(response.text)</span><br><span class="line">    df = pd.read_csv(f, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>] )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">twii = crawl_price(<span class="string">"^TWII"</span>)</span><br><span class="line">twii.head()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/2.png" title="台股"></center><h3 id="2-編寫台股的sharpe-ratio"><a href="#2-編寫台股的sharpe-ratio" class="headerlink" title="2. 編寫台股的sharpe ratio"></a>2. 編寫台股的sharpe ratio</h3><p>接下來我們就來計算sharpe ratio，這邊同樣於「<a href="/Python新手教學：風險與報酬/">Python新手教學：風險與報酬</a>」講過了<br>就請有興趣的大家多多複習囉！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean = twii[<span class="string">'Adj Close'</span>].pct_change().rolling(<span class="number">252</span>).mean()</span><br><span class="line">std = twii[<span class="string">'Adj Close'</span>].pct_change().rolling(<span class="number">252</span>).std()</span><br><span class="line"></span><br><span class="line">sharpe = mean / std</span><br><span class="line"></span><br><span class="line">twii.Close.plot()</span><br><span class="line">sharpe.plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/3.png" title="夏普"></center><h3 id="3-編寫台股sharpe-ratio策略"><a href="#3-編寫台股sharpe-ratio策略" class="headerlink" title="3. 編寫台股sharpe ratio策略"></a>3. 編寫台股sharpe ratio策略</h3><p>接下來就是編寫sharpe ratio 的策略了，同樣可以到<a href="python新手教學：夏普指數策略/">python新手教學：夏普指數策略</a><br>這篇文章中，得到更詳細的解釋</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># sharpe ratio 平滑</span></span><br><span class="line">sr = sharpe</span><br><span class="line">srsma = sr.rolling(<span class="number">60</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sharpe ratio 的斜率</span></span><br><span class="line">srsmadiff = srsma.diff()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算買入賣出點</span></span><br><span class="line">buy = (srsmadiff &gt; <span class="number">0</span>) &amp; (srsmadiff.shift() &lt; <span class="number">0</span>)</span><br><span class="line">sell = (srsmadiff &lt; <span class="number">0</span>) &amp; (srsmadiff.shift() &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算持有時間</span></span><br><span class="line">hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">hold[buy] = <span class="number">1</span></span><br><span class="line">hold[sell] = <span class="number">0</span></span><br><span class="line">hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">hold.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持有時候的績效</span></span><br><span class="line">adj = twii[<span class="string">'Adj Close'</span>][buy.index]</span><br><span class="line">(adj.pct_change().shift(<span class="number">-1</span>)+<span class="number">1</span>).fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod().plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/5.png" title="回測結果"></center><h3 id="別轉台，終於要開始參數最佳化了"><a href="#別轉台，終於要開始參數最佳化了" class="headerlink" title="別轉台，終於要開始參數最佳化了"></a>別轉台，終於要開始參數最佳化了</h3><p>我們將上面的程式碼包成一個函示如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtest</span><span class="params">(a, b, c, d)</span>:</span></span><br><span class="line">    sr = sharpe</span><br><span class="line">    srsma = sr.rolling(a).mean()</span><br><span class="line"></span><br><span class="line">    srsmadiff = srsma.diff() * <span class="number">100</span></span><br><span class="line">    ub = srsmadiff.quantile(b)</span><br><span class="line">    lb = srsmadiff.quantile(c)</span><br><span class="line">    </span><br><span class="line">    buy = ((srsmadiff.shift(d) &lt; lb) &amp; (srsmadiff &gt; ub))</span><br><span class="line">    sell = ((srsmadiff.shift(d) &gt; ub) &amp; (srsmadiff &lt; lb))</span><br><span class="line"></span><br><span class="line">    hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">    hold[buy] = <span class="number">1</span></span><br><span class="line">    hold[sell] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    adj = twii[<span class="string">'Adj Close'</span>][buy.index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># eq = (adj.pct_change().shift(-1)+1).fillna(1)[hold == 1].cumprod().plot()</span></span><br><span class="line">    <span class="comment"># hold.plot()</span></span><br><span class="line">    eq = (adj.pct_change().shift(<span class="number">-1</span>)+<span class="number">1</span>).fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod()</span><br><span class="line">    <span class="keyword">if</span> len(eq) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> eq.iloc[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backtest(<span class="number">252</span>,<span class="number">0.4</span>,<span class="number">0.6</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以發現，這個function傳入了四個參數「a,b,c,d」，<br>而這四個參數是做什麼的呢？是拿來取代原本的數字的，<br>可以發現原本的常數部分，都被換成了代數，這樣我們到時候在呼叫時，就可以帶入不同的參數<br>而我們最後的回傳值，原本是一張圖片，但此function中被改成了這20年的報酬率<br>所以當我們執行「backtest(252,0.4,0.6,4)」的時候，<br>這20年的報酬就是9.1%，非常爛<br>所以我們才需要做參數優化</p><h3 id="參數枚舉優化"><a href="#參數枚舉優化" class="headerlink" title="參數枚舉優化"></a>參數枚舉優化</h3><p>我們使用暴力法，將所有的可能的參數都找一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maxeq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">100</span>,<span class="number">200</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> np.arange(<span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">0.03</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> np.arange(<span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.03</span>):</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">60</span>, <span class="number">180</span>, <span class="number">10</span>):</span><br><span class="line">                </span><br><span class="line">                eq = backtest(a,b,c,d)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> maxeq &lt; eq:</span><br><span class="line">                    maxeq = eq</span><br><span class="line">                    print(eq, a,b,c,d)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學：策略優化/3.png" title="最終成果"></center><p>上面第8行，即是我們執行backtest的結果，<br>假如我們發現eq，有最高報酬率，<br>則將新的最高報酬率print出來，並且print它的參數<br>我們就可以看到數字不斷增加的感覺，滿開心的！<br>不過上述程式要跑滿久的，請耐心等待，</p><p>最後成果滿不錯的，算是一個懶人投資策略：</p><center><img src="/Python新手教學：策略優化/4.png" title="最終成果"></center><p>有興趣的可以到<a href="https://www.facebook.com/finlab.python/?ref=bookmarks" rel="external nofollow noopener noreferrer" target="_blank">粉絲團</a>按讚，才不會錯過接下來精彩文章喔！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章中，帶大家寫了一個簡單的策略，&lt;br&gt;然而，在現實生活中並沒有這麼管用，20年才賺三倍！？&lt;/p&gt;
&lt;p&gt;所以這篇文章將帶介紹如何利用修改參數，來調整策略，進而達到更好的績效&lt;br&gt;但是人工調整參數很浪費時間，所以我們先使用簡單暴力法，來調整參數試試看。&lt;/p&gt;

      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>python新手教學(6)：夏普指數策略</title>
    <link href="https://www.finlab.tw/python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E5%A4%8F%E6%99%AE%E6%8C%87%E6%95%B8%E7%AD%96%E7%95%A5/"/>
    <id>https://www.finlab.tw/python新手教學：夏普指數策略/</id>
    <published>2019-02-19T12:46:47.000Z</published>
    <updated>2019-03-11T11:17:28.518Z</updated>
    
    <content type="html"><![CDATA[<p>上一集我們介紹了Sharpe ratio，可以用來衡量風險跟報酬的指標（也就是報酬 / 風險），這集我們就利用Sharpe ratio來進行台股的模擬買賣，假裝我們這20年來，都使用sharpe ratio的策略，可以得到多少獲利呢？</p><a id="more"></a><center><img src="/python新手教學：夏普指數策略/6.png" title="績效計算"></center><h3 id="為何Sharpe-ratio幾乎都小於一"><a href="#為何Sharpe-ratio幾乎都小於一" class="headerlink" title="為何Sharpe ratio幾乎都小於一"></a>為何Sharpe ratio幾乎都小於一</h3><p>上次有人問我，夏普指標小於一，代表風險（分母）大於獲利（分子），而為什麼市面上所有的指數，其sharpe ratio都小於一，難道股票都不能賺錢嗎？</p><p>這只是代表，在股市中，我們為了要獲利，往往需要承受很大的風險！但不代表長期投資下來是不能獲利的。我們必須要找到sharpe ratio比較高的策略，才能使風險降低，獲利升高。</p><h3 id="利用Python研發一個策略"><a href="#利用Python研發一個策略" class="headerlink" title="利用Python研發一個策略"></a>利用Python研發一個策略</h3><p>首先，我們得準備台股的歷史紀錄，還有台股的夏普指標，假如之前沒有跟上，可以到<a href="/Python新手教學：風險與報酬/">上一個單元</a>複習一下喔！：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>].plot()</span><br><span class="line">sharpe[<span class="string">'TSEC weighted index'</span>].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/1.png" title="台灣指數以及夏普"></center><p>可以發現，當sharpe ratio比較低時，台股也都是在比較低點，<br>可以發現，當sharpe ratio比較高時，台股也都是在比較高點，<br>當sharpe ratio 轉折時，通常也是台股會轉折的時候</p><p>利用這個觀察，我們就可以來編寫一個策略：</p><ol><li>當sharpe ratio往上轉折時，則買入</li><li>當sharpe ratio往下轉折時，則賣出</li></ol><h3 id="利用Python快速編寫"><a href="#利用Python快速編寫" class="headerlink" title="利用Python快速編寫"></a>利用Python快速編寫</h3><p>為了找出轉折點，我們必須做一點資料處理：</p><ol><li>時間序列的平滑</li><li>時間序列的斜率</li><li>找出斜率由正到負，或由負到正的訊號</li></ol><p>為了使用python寫出上述的策略，我們要先將夏普值平滑一下，不然雜訊太多了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sr = sharpe[<span class="string">'TSEC weighted index'</span>].dropna()</span><br><span class="line"></span><br><span class="line">d = <span class="number">60</span></span><br><span class="line">srsma = sr.rolling(d).mean()</span><br><span class="line">sr.plot()</span><br><span class="line">srsma.plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/2.png" title="sma後"></center><p>來色的線是我們就將sharpe ratio做移動窗格的平均，可以發現平均之後，時間序列比較平滑，這樣子我們找轉折點比較方便，所謂的轉折點，就是斜率由正到負，或由負到正的瞬間，所以我們要先找出夏普曲線的斜率。</p><h3 id="夏普曲線的斜率"><a href="#夏普曲線的斜率" class="headerlink" title="夏普曲線的斜率"></a>夏普曲線的斜率</h3><p>斜率非常簡單，可以使用<code>diff</code>這個功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">srsma = sr.rolling(d).mean()</span><br><span class="line">srsmadiff = srsma.diff()</span><br><span class="line">srsma.plot()</span><br><span class="line">srsmadiff.plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><center><img src="/python新手教學：夏普指數策略/3.png" title="計算斜率"></center><p>可以發現上圖中，橘色的為sharpe ratio，藍色的為斜率，當橘色線由上而下轉折時，藍色的線會快速向下穿越0，有了這個特性，我們就可以來找轉折點了！</p><h3 id="找轉折點"><a href="#找轉折點" class="headerlink" title="找轉折點"></a>找轉折點</h3><p>接下來我們可以來找轉折點了，就是斜率由正到負，或由負到正的瞬間。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buy = (srsmadiff &gt; <span class="number">0</span>) &amp; (srsmadiff.shift() &lt; <span class="number">0</span>)</span><br><span class="line">sell = (srsmadiff &lt; <span class="number">0</span>) &amp; (srsmadiff.shift() &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">(buy * <span class="number">1</span>).plot()</span><br><span class="line">(sell * <span class="number">-1</span>).plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/4.png" title="找出訊號"></center><p>以上就是簡單的訊號產生</p><h3 id="找出持有的時段"><a href="#找出持有的時段" class="headerlink" title="找出持有的時段"></a>找出持有的時段</h3><p>那我們就可以來看一下，假如天都用一樣的方式來產生這些訊號，當 <code>buy</code>訊號為<code>True</code>時，買入，而當<code>sell=True</code>時空手，如此執行20年的持有加權指數的時段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">hold = pd.Series(np.nan, index=buy.index)</span><br><span class="line">hold[buy] = <span class="number">1</span></span><br><span class="line">hold[sell] = <span class="number">-1</span></span><br><span class="line">hold.ffill(inplace=<span class="keyword">True</span>)</span><br><span class="line">hold.plot()</span><br></pre></td></tr></table></figure><center><img src="/python新手教學：夏普指數策略/5.png" title="找出持股時間"></center><p>交易頻率似乎有點高，不過沒關係，我們之後還會再做調整<br>接來是回測</p><h3 id="回測"><a href="#回測" class="headerlink" title="回測"></a>回測</h3><p>今天我們先簡單算一算，不考慮手續費，但是真實情況是必須考慮的喔！請謹記在心</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">twii = adjclose[<span class="string">'TSEC weighted index'</span>][buy.index]</span><br><span class="line"></span><br><span class="line">pct_change = twii.pct_change()</span><br><span class="line">pct_ratio = (pct_change.shift(<span class="number">-1</span>)+<span class="number">1</span>) <span class="comment"># 今天到明天的價格變化</span></span><br><span class="line"></span><br><span class="line">pct_ratio.fillna(<span class="number">1</span>)[hold == <span class="number">1</span>].cumprod().plot()</span><br></pre></td></tr></table></figure><p>這段程式碼，有點複雜，當中的<code>pct_change</code>是一個每天獲利上下 x％。<br>而<code>pct_ratio</code>代表買入之後每天的變化（不漲不跌是1，大於1則漲，小於1則跌）<br>我們希望將「持有」時間段的<code>pct_ratio</code>全部都乘起來，代表獲利。</p><center><img src="/python新手教學：夏普指數策略/6.png" title="計算績效"></center><p>可以發現，這個策略效果並不是很好，不過別擔心<br><a href="/Python新手教學：策略優化/">下個單元</a>，我們使用參數最佳化，從5000種組合中，找出最好的策略！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一集我們介紹了Sharpe ratio，可以用來衡量風險跟報酬的指標（也就是報酬 / 風險），這集我們就利用Sharpe ratio來進行台股的模擬買賣，假裝我們這20年來，都使用sharpe ratio的策略，可以得到多少獲利呢？&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(5)如何衡量風險與報酬？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B8%EF%BC%9A%E9%A2%A8%E9%9A%AA%E8%88%87%E5%A0%B1%E9%85%AC/"/>
    <id>https://www.finlab.tw/Python新手教學：風險與報酬/</id>
    <published>2019-02-14T05:09:43.000Z</published>
    <updated>2019-05-06T12:43:00.185Z</updated>
    
    <content type="html"><![CDATA[<p>今天我們來看一下市場上常見的風險與報酬指標：夏普比率（sharpe ratio），這是一個風險跟報酬的比例，有了夏普比率，你就知道為什麼要投資美股而不是台股了！</p><a id="more"></a><center><img src="/Python新手教學：風險與報酬/thumbnail.png" title="報酬與風險"></center><h3 id="sharp-ratio-簡單講，就是「報酬-風險」！"><a href="#sharp-ratio-簡單講，就是「報酬-風險」！" class="headerlink" title="sharp ratio 簡單講，就是「報酬 / 風險」！"></a>sharp ratio 簡單講，就是「報酬 / 風險」！</h3><p>以這著比率，可以想像，sharp ratio 越高，代表獲利大於風險，<br>而sharp ratio 越低，代表風險大於獲利，那就會有點危險了！<br>所以找一個sharp ratio 越高的指數，就等於找出了「獲利大且風險相對小」的指數喔！</p><h3 id="如何定義獲利？"><a href="#如何定義獲利？" class="headerlink" title="如何定義獲利？"></a>如何定義獲利？</h3><p>獲利可以用每天平均的漲跌來代表，也就是今天漲1％，明天跌1％，平均獲利就是0％，<br>接下來我們就用python來計算每天平均獲利吧</p><p>首先，記得回去前一個單元，找出上次的adjclose：</p><center><img src="/Python新手教學：風險與報酬/1.png" title="adjclose"></center><p>接下來，我們就可以來計算獲利：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pct_change = adjclose.pct_change()</span><br><span class="line">profit = pct_change.mean()</span><br><span class="line">profit.sort_values()</span><br></pre></td></tr></table></figure><br>上方的程式碼，<br>第一行，有好用的功能，叫做<code>adjclose.pct_change()</code>，這個函示會計算今天漲了x％，並且以x/100來表示，將整個table中的每一條時間序列都進行計算喔！<br>第二行，針對每一檔指數，將每一天的漲跌都平均起來，<br>第三行，進行由小到大的排序</p><center><img src="/Python新手教學：風險與報酬/2.png" title="報酬"></center><p>以平均獲利來說，看到台股（TSEC weighted index）竟然排在倒數第三位，<br>可以見台灣投資人多麼可憐XDD</p><h3 id="如何衡量風險"><a href="#如何衡量風險" class="headerlink" title="如何衡量風險"></a>如何衡量風險</h3><p>風險通常會用標準差（standard deviation）來計算，標準差，可以想像是股票震盪的程度，例如金融海嘯的時候，股票上上下下的比較劇烈，標準差很大。今天就不折磨各位了，有興趣請參考<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%99%E6%BA%96%E5%B7%AE" rel="external nofollow noopener noreferrer" target="_blank">wiki介紹</a>，我們直接用 python 當中現有的程式碼來計算即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">risk = pct_change.std()</span><br></pre></td></tr></table></figure><h3 id="計算sharpe-ratio"><a href="#計算sharpe-ratio" class="headerlink" title="計算sharpe ratio"></a>計算sharpe ratio</h3><p>這個就更簡單了，直接相除即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br><span class="line">sharpe.sort_values()</span><br></pre></td></tr></table></figure><br>可以看到上述程式，我們額外乘了一個「252 ** 0.5」<br>因為我們希望算年化 annual sharpe ratio，<br>其中的252是一年大約的交易天數，<br>而「**」是「次方」的意思。<br>為什麼要乘這個常數？最主要是因為大家幫自己的歷史回測計算sharpe ratio時候，都有乘上這個數字，要乘了才有辦法跟別人比較XD，<br>當然這背後可能有更深層的數學邏輯，但我傾向於這樣理解（懶）。</p><center><img src="/Python新手教學：風險與報酬/6.png" title="夏普值"></center><p>你會發現</p><h3 id="台股竟然倒數第三名！"><a href="#台股竟然倒數第三名！" class="headerlink" title="台股竟然倒數第三名！"></a>台股竟然倒數第三名！</h3><p>可以發現台股真的好慘，慘不忍睹，為什麼會這樣呢，我們可以將歷史圖表畫出來：</p><center><img src="/Python新手教學：風險與報酬/3.png" title="台股"></center><p>可以發現因為我們是從1998年開始計算的，那個時候剛好也上萬點，跟現在的萬點是同一個萬點，反觀我們來看美股：</p><center><img src="/Python新手教學：風險與報酬/4.png" title="美股"></center><p>可以看到從1998年開始，直到現在漲了將近3倍！<br>可見台股的獲利不理想是導致於sharpe ratio比較低的很大的因素。</p><p>我們目前計算的sharpe ratio，是所有歷史資料的平均值，<br>然而我們知道，雖然台股總平均來說很爛，但是應該有時也有可圈可點之處，<br>我們希望用時間移動窗格，每日都計算252天以前的sharpe值，</p><p>來找出台股表現比較好的時段</p><h3 id="移動窗格"><a href="#移動窗格" class="headerlink" title="移動窗格"></a>移動窗格</h3><p>你以為這個很難嗎？其實超簡單，跟上面幾乎一樣，只要做一點小更改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># before</span></span><br><span class="line">profit = pct_change.mean()</span><br><span class="line">risk = pct_change.std()</span><br><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># after</span></span><br><span class="line">profit = pct_change.rolling(<span class="number">252</span>).mean()</span><br><span class="line">risk = pct_change.rolling(<span class="number">252</span>).std()</span><br><span class="line">sharpe = profit / risk * (<span class="number">252</span> ** <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>幾乎長的一模一樣對吧？唯一不一樣的是<code>rolling(252)</code>這個功能，<br>這是移動窗格252天的意思。<br>額外要注意的是，之前的寫法中，sharpe是一個series，index為指數名稱，而在現在的寫法中，sharpe變成了一個dataframe（table），其index代表日期，而columns代表每檔指數，其中的數值是 252 天的 sharpe ratio，神奇吧！</p><p>這就是python跟R最強大的資料處理功能！</p><p>有了這個移動窗格版的sharpe ratio，我們做圖後，就可以來看一些端倪：</p><h3 id="做圖看端倪"><a href="#做圖看端倪" class="headerlink" title="做圖看端倪"></a>做圖看端倪</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>].plot()</span><br><span class="line">sharpe[<span class="string">'TSEC weighted index'</span>].plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>以上的代碼可以繪出下面這張圖，其中藍色的為加權指數，而黃色的為sharpe ratio，由於這兩個時間序列的數值差非常多，台股可能是在4000～10000左右，而sharpe可能是在-2～2左右，所以上方第二行程式中，我們用<code>secondary_y=True</code>這個參數，來將兩個數值的座標分開，所以下方的圖中，可以看到sharpe ratio的大小標示在右邊。</p><center><img src="/Python新手教學：風險與報酬/5.png" title="夏普與加權指數"></center><p>可以看到，sharpe ratio （黃）在台股加權指數（藍）高點時，會比較大，而台股低點時，會比較低<br>圖中還可以看出，在大盤高點時，sharpe ratio會領先大盤往下落，接下來我們就可以利用這個特點，來模擬一些買賣的實驗。</p><p>下次我們就來創造一個夏普策略吧！<br>其實程式碼已經寫好了，但還沒時間寫文章<br>接下來就可以進入<a href="/python新手教學：夏普指數策略/">下一單元</a>，我們利用sharpe ratio來寫一個策略吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我們來看一下市場上常見的風險與報酬指標：夏普比率（sharpe ratio），這是一個風險跟報酬的比例，有了夏普比率，你就知道為什麼要投資美股而不是台股了！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(4)台股跟哪國指數最相關？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B84%E7%9B%B8%E9%97%9C%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>https://www.finlab.tw/Python新手教學4相關性分析/</id>
    <published>2019-02-10T03:10:58.000Z</published>
    <updated>2019-02-15T04:24:56.639Z</updated>
    
    <content type="html"><![CDATA[<p>為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！想知道台股跟哪國指數最同步嗎？不是S&amp;P 500美國指數，也不是深圳指數，那究竟是哪國呢？這篇文章我們就來研究一下吧！</p><a id="more"></a><center><img src="/Python新手教學4相關性分析/last.png" title="全球指數相關性"></center><h3 id="相關性最白話"><a href="#相關性最白話" class="headerlink" title="相關性最白話"></a>相關性最白話</h3><p>首先我們先介紹什麼是相關性，<br>相關性最白話，你可以想像，看到天空烏雲密佈，代表可能要下雨了，<br>代表天空的顏色跟下雨機率有相關，<br>你可以由一個現象，去預測另一個現象，這就是相關性！</p><h3 id="相關性稍微數學一點"><a href="#相關性稍微數學一點" class="headerlink" title="相關性稍微數學一點"></a>相關性稍微數學一點</h3><p>相關性也可以更數值化的方式表示，先用以下例子講解：</p><center><img src="/Python新手教學4相關性分析/2.png" title="天氣溫度相關性"></center><p>這張圖中：</p><ul><li><p>我們可以看上方左側圖，天氣溫度跟買冰棒人數的變化圖，可以想像某人每一天記錄天氣溫度與冰棒人數，每天畫一個黃點，時間久了，就可以看出黃點之間的關係，也就是天氣越熱，越有人會想要買冰棒！</p></li><li><p>同理，上方中間那張圖，某人也可以記錄每天生病的人數，此時就發現，天氣越冷，越多人會感冒！</p></li><li><p>當然某人覺得有趣，於是又記錄了溫度與擲筊的關係，最後發現：沒什麼關連</p></li></ul><p>好了，某人已將觀測值變成數字記錄起來了，但每次都必須畫這麼多點，才能看出相關性，也太累了吧？能不能用一個數字取代呢？</p><p>這時就可以用</p><h3 id="correlation-coefficient-（相關性係數）"><a href="#correlation-coefficient-（相關性係數）" class="headerlink" title="correlation coefficient （相關性係數）"></a>correlation coefficient （相關性係數）</h3><p>有人可能覺得太多點點了，有密集恐懼症，希望可以將上方這三張圖，每張圖用一個數字代表就好，這樣就不需要看到這麼多點點。</p><p>所以某人提出了 correlation coefficient ，從上面第一張圖開始從左而又，分別可以用 1、-1、0來代表：</p><ul><li>1 代表正相關，也就是X越高Y越高，X越低Y越低（成正比）</li><li>─1 代表負相關，也就是X越高Y越低，或X越低Y越高（成反比）</li><li>0 代表無相關性</li></ul><p>上述只是化簡後的例子<br>事實上相關性係數不是整數，而是會介於─1～1間，代表正負相關的程度！</p><p>讀到這裡，你可能會問，</p><h3 id="所以跟投資有什麼關係？"><a href="#所以跟投資有什麼關係？" class="headerlink" title="所以跟投資有什麼關係？"></a>所以跟投資有什麼關係？</h3><p>投資就是預測未來現象與當下現象的相關性！<br>就像你看到天空烏雲密佈，就能預測接下來會下雨，<br>我們也可以將相關性係數用於全球指數，</p><p>為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！<br>台股跟美股有正相關。</p><p>我們可以用Python將相關性畫出來，</p><h2 id="首先我們可以看一下上個單元的一些元素："><a href="#首先我們可以看一下上個單元的一些元素：" class="headerlink" title="首先我們可以看一下上個單元的一些元素："></a>首先我們可以看一下上個單元的一些元素：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(world_index_history[<span class="string">'S&amp;P 500'</span>].head())</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/3.png" title="回顧指數"></center><p>還記得<code>world_index_history</code>嗎？它是一個dictionary，根據不同的字串，例如<code>S&amp;P 500</code>，可以叫出相對應的表格（dataframe）</p><p>有了 <code>world_index_history</code> 我們就可以將國際指數的相關性給畫出來，但首先，我們要先來瞭解</p><h3 id="Adj-Close跟Close的差異？"><a href="#Adj-Close跟Close的差異？" class="headerlink" title="Adj Close跟Close的差異？"></a><code>Adj Close</code>跟<code>Close</code>的差異？</h3><p><code>close</code> 就是收盤價，每天股市休盤瞬間的最後數字。那<code>Adj Close</code>呢？<br>我們用圖會比較好解說，先將 <code>S&amp;P500</code> 指數的 <code>Adj Close</code> 跟 <code>Close</code> 畫出來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp500 = world_index_history[<span class="string">'S&amp;P 500'</span>]</span><br><span class="line">sp500[<span class="string">'Close'</span>].plot(color=<span class="string">'red'</span>)</span><br><span class="line">sp500[<span class="string">'Adj Close'</span>].plot(color=<span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/4.png" title="收盤價與調整後收盤價"></center><p>上圖中紅色的為<code>Close</code>而藍色的為<code>Adj Close</code>，兩者幾乎重疊，因為<code>Adj Close</code>其實跟<code>Close</code>很像，但是有點不同，台灣叫做「調整後收盤價」，你有時候也會看到「復權收盤價」。這個價格的好處是，它移除了除權息和增減資的價格波動，更準確的反映了「股票價值」的變化。</p><h3 id="簡單的例子"><a href="#簡單的例子" class="headerlink" title="簡單的例子"></a>簡單的例子</h3><p>當除權息、增減資時，一般股價會有大波動，以除權息為例，股票價格瞬間下跌<br>然而帳戶裡的股票張數會變多（例如領股利）<br>或是帳戶資金量變多（領股息）<br>總體來講是不賺不賠的</p><p>所以當除權息時，<br>收盤價 <code>Close</code> 會突然下跌很多，<br>而調整後收盤價 <code>Adj Close</code> 不會因為除權息有巨幅下跌<br>更能夠精確的反映股票價值，跟投資的獲利狀況！<br>所以我們在做相關性分析，可以用 <code>Adj Close</code>！</p><h3 id="Python-終於開始了"><a href="#Python-終於開始了" class="headerlink" title="Python 終於開始了"></a>Python 終於開始了</h3><p>首先我們先將所有指數的 <code>Adj Close</code> 先集合起來，變成一張表格(dataframe)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adjclose = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> name, price <span class="keyword">in</span> world_index_history.items():</span><br><span class="line">    <span class="keyword">if</span> price.index.is_unique:</span><br><span class="line">        adjclose[name] = price[<span class="string">'Adj Close'</span>]</span><br><span class="line">    </span><br><span class="line">adjclose = pd.DataFrame(adjclose)</span><br><span class="line">adjclose</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/5.png" title="調整後收盤價的表格"></center><p>接下來就可以來觀察每檔指數的 <code>Adj Close</code> 相關性，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">corr = adjclose.corr()</span><br><span class="line">print(corr)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/6.png" title="相關性matrix"></center><p>上圖可以看到一個二維的表，就是每個指數跟每個指數之間的相關性，<br>上圖中可以發現，指數自己跟自己的相關性一定是1，代表完全正相關！<br>而這張表會是symmetric matrix，也就是做對角線會是對稱的。</p><p>接下來我們可以用更視覺化的方式來表示，假如沒有sns的package，要記得先去安裝<code>pip install sns</code>即可，想瞭解如何安裝，可以到<a href="/Python股票投資/">此安裝教學</a>的下半部分，有簡單的教學喔！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.heatmap(corr, square=<span class="keyword">True</span> ,vmax=<span class="number">1.0</span>, linecolor=<span class="string">'white'</span>, annot=<span class="keyword">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學4相關性分析/last.png" title="相關性圖"></center><p>假如你發現圖比我的小，字看不清楚，可以改成以下程式碼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># set figure size</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">18</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># original code</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.heatmap(corr, square=<span class="keyword">True</span> ,vmax=<span class="number">1.0</span>, linecolor=<span class="string">'white'</span>, annot=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>有了以上的code，我們就可以知道</p><h3 id="台灣股票跟誰最連動"><a href="#台灣股票跟誰最連動" class="headerlink" title="台灣股票跟誰最連動"></a>台灣股票跟誰最連動</h3><p>我們可以人眼觀察，發現台灣指數<code>TSEC weighted index</code>跟英國前一百大<code>Cboe UK 100</code>超像！相關係數高達0.9，代表非常非常像</p><p>我們可以將這兩個指數畫出來檢查一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adjclose[<span class="string">'Cboe UK 100 Price Return'</span>][<span class="string">'2015'</span>:].plot()</span><br><span class="line">adjclose[<span class="string">'TSEC weighted index'</span>][<span class="string">'2015'</span>:].plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學4相關性分析/7.png" title="英國指數與台灣指數"></center><p>雖然價格不同，但是趨勢還真的頗像的耶！</p><h3 id="如何用於交易？"><a href="#如何用於交易？" class="headerlink" title="如何用於交易？"></a>如何用於交易？</h3><p>兩個相關性很高的股票，可以拿來做pair trading配對交易，但也不是只看相關性，<br>這個就容我們之後再慢慢分析吧！<br>這個單元會一直帶你從零開始，慢慢學習，直到機器學習的部分喔！敬請期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;為什麼美股大跌，在台灣的投資人要很緊張？原因就是相關性！想知道台股跟哪國指數最同步嗎？不是S&amp;amp;P 500美國指數，也不是深圳指數，那究竟是哪國呢？這篇文章我們就來研究一下吧！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(3)全球指數歷史數據</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B83%E5%85%A8%E7%90%83%E6%8C%87%E6%95%B8%E6%AD%B7%E5%8F%B2%E6%95%B8%E6%93%9A/"/>
    <id>https://www.finlab.tw/Python新手教學3全球指數歷史數據/</id>
    <published>2019-02-06T01:57:32.000Z</published>
    <updated>2019-02-10T14:20:31.973Z</updated>
    
    <content type="html"><![CDATA[<p>這個單元我們要利用 for 迴圈將所有的歷史數據爬下來，並且繪製所有的歷史股價。我們也會介紹一些 for 迴圈的進階技巧，並且將這些技巧結合起來，完成這次的功能，想要學習python，就慢慢跟著我們一步一步來吧！</p><a id="more"></a><center><img src="/Python新手教學3全球指數歷史數據/thumbnail.png" title="全球爬蟲"></center><p>延續上個單元，我們應該已經爬取了<code>world_index</code>這張表格：</p><center><img src="/Python新手教學3全球指數歷史數據/1.png" title="全球指數表格"></center><p>然後還有一個我們寫好的function</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line">    now = int(datetime.datetime.now().timestamp())+<span class="number">86400</span></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/"</span> + stock_id + <span class="string">"?period1=0&amp;period2="</span> + str(now) + <span class="string">"&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    response = requests.post(url)</span><br><span class="line"></span><br><span class="line">    f = io.StringIO(response.text)</span><br><span class="line">    df = pd.read_csv(f, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>] )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>接下來就可以將他們結合，來爬取歷史資料了！在爬取資料之前，有幾個程式的小技巧必須要學會</p><h3 id="1-for-迴圈"><a href="#1-for-迴圈" class="headerlink" title="1. for 迴圈"></a>1. for 迴圈</h3><p>假如我們要執行重複性的動作，通常第一件事情就是想到for 迴圈，例如我們想要印出1～9，不用for迴圈，我們可以寫成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span>)</span><br><span class="line">print(<span class="number">2</span>)</span><br><span class="line">print(<span class="number">3</span>)</span><br><span class="line">print(<span class="number">4</span>)</span><br><span class="line">print(<span class="number">5</span>)</span><br><span class="line">print(<span class="number">6</span>)</span><br><span class="line">print(<span class="number">7</span>)</span><br><span class="line">print(<span class="number">8</span>)</span><br><span class="line">print(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/2.png" title="印出1到9"></center><p>但很明顯我們就已經快要中風了，所以改成for迴圈後<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/3.png" title="印出1到9FOR迴圈"></center><p>這樣短短的就寫完了！其中<br>第一行：我們有一個變數i，他會從1～9不斷變換，並且執行下方的print(i)。第二行要記得加上前方四個空白，通常叫做縮排「indent」，當第一行有<code>for</code>這個標示後，之後就必須用縮排indent直到寫完for迴圈裡的內容為止。</p><p>但有時候我們希望同時做兩個迴圈呢？</p><h3 id="使用zip"><a href="#使用zip" class="headerlink" title="使用zip"></a>使用zip</h3><p>我們可以使用zip，一次執行兩個list：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number, letter <span class="keyword">in</span> zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(number, letter)</span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/4.png" title="使用zip"></center><p>最後，我們要使用 dictionary 將全球的指數給存起來。</p><h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><p>這邊先示範最簡單的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">print(d[<span class="string">'b'</span>]) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迴圈</span></span><br><span class="line"><span class="comment"># 其中，d.items 有點像是zip的感覺，</span></span><br><span class="line"><span class="comment"># 針對dictionary中的['a', 'b']和[1,2]進行迴圈）</span></span><br><span class="line"><span class="keyword">for</span> letter, number <span class="keyword">in</span> d.items():</span><br><span class="line">    print(letter, number)</span><br><span class="line"><span class="comment"># a 1</span></span><br><span class="line"><span class="comment"># b 2</span></span><br></pre></td></tr></table></figure></p><center><img src="/Python新手教學3全球指數歷史數據/6.png" title="使用zip"></center><p>結合上述的小功能，就可以寫一個程式將世界指數都抓下來了！<br>我建議你自己試試看～<br>寫完之後再往下拉看範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">world_index_history = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> symbol, name <span class="keyword">in</span> zip(world_index[<span class="string">'Symbol'</span>], world_index[<span class="string">'Name'</span>]):</span><br><span class="line">    </span><br><span class="line">    print(name)</span><br><span class="line">    </span><br><span class="line">    world_index_history[name] = crawl_price(symbol)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/5.png" title="全球歷史股價"></center><p>假如你有認真研究前三點功能，相信這些代碼應該難不倒你！其中沒有教到的是，我們利用<code>time.sleep(5)</code>，來休息一下，不要抓的太頻繁，不然會被封鎖，除此之外，上述代碼非常簡單，寫一個for迴圈，將所有的指數都抓下來，存在<code>world_index_history</code>中。</p><h3 id="繪製指數"><a href="#繪製指數" class="headerlink" title="繪製指數"></a>繪製指數</h3><p>接下來，我們可以用一樣的for迴圈，來將指數給畫出來</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, history <span class="keyword">in</span> world_index_history.items():</span><br><span class="line">    history.Close.plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學3全球指數歷史數據/f.png" title="全球歷史股價"></center><h3 id="有了指數，接下來要做什麼呢？"><a href="#有了指數，接下來要做什麼呢？" class="headerlink" title="有了指數，接下來要做什麼呢？"></a>有了指數，接下來要做什麼呢？</h3><p>下個單元，我們要來分析一下這些指數，看看哪些適合投資，哪些不適合，敬請期待～</p><p>這一系列是我們影音課程的化簡版，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這個單元我們要利用 for 迴圈將所有的歷史數據爬下來，並且繪製所有的歷史股價。我們也會介紹一些 for 迴圈的進階技巧，並且將這些技巧結合起來，完成這次的功能，想要學習python，就慢慢跟著我們一步一步來吧！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(2)全球指數一次抓</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B82%E5%85%A8%E7%90%83%E6%8C%87%E6%95%B8%E4%B8%80%E6%AC%A1%E6%8A%93/"/>
    <id>https://www.finlab.tw/Python新手教學2全球指數一次抓/</id>
    <published>2019-02-05T14:55:54.000Z</published>
    <updated>2019-02-10T14:22:48.908Z</updated>
    
    <content type="html"><![CDATA[<p>我們已經知道怎麼抓取任意一檔股票歷史價格了，但有時候我們一次需要很多檔股票，怎麼辦呢？難道每個股票我們都要寫這麼多行，才能抓下來嗎？今天我們教你如何將上一次的功能包裝成 function，然後一次下載全球指數！</p><a id="more"></a><center><img src="/Python新手教學2全球指數一次抓/thumbnail.png" title="全球爬蟲"></center><h3 id="上次的程式碼爬取台積電"><a href="#上次的程式碼爬取台積電" class="headerlink" title="上次的程式碼爬取台積電"></a>上次的程式碼爬取台積電</h3><p>首先，我們上次已經教了怎麼樣爬取一檔股票：「台積電2330」，這次我們重新複習一下，下方的程式，假如有任何一個部分忘記了，都可以去<a href="/用爬蟲爬全世界股價/">前一個單元</a>複習喔！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 使用jupyter notebook 要加：</span></span><br><span class="line"><span class="comment"># %matplitlib inline</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/2330.TW?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(response.text)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>])</span><br><span class="line">df.Close.plot()</span><br></pre></td></tr></table></figure><center><img src="/Python新手教學2全球指數一次抓/1.png" title="歷史股價爬蟲"></center><p>但是以上的程式碼只能爬「台積電」的股價，我想要爬其他的指數怎麼辦呢？</p><h3 id="將上述程式碼打包成function"><a href="#將上述程式碼打包成function" class="headerlink" title="將上述程式碼打包成function"></a>將上述程式碼打包成function</h3><p>我們可以用<code>function</code>將上面的程式碼打包起來，方便我們多次使用，變成下面這樣，其實跟之前長的非常像，可以先比較一下：首先，第一行多了<code>def crawl_price(stock_id):</code>，這行的意思就是宣告一個可呼叫的程式區塊，叫做<code>crawl_price(stock_id)</code>，再來，原本的程式碼前方都被加了4個空白格，代表這些功能是同一個<code>function</code>中被執行的代碼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line">    now = int(datetime.datetime.now().timestamp())+<span class="number">86400</span></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/"</span> + stock_id + <span class="string">"?period1=0&amp;period2="</span> + str(now) + <span class="string">"&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line">    response = requests.post(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'file.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.writelines(response.text)</span><br><span class="line"></span><br><span class="line">    df = pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>上面的代碼中，有個特別可以注意的變數：<code>stock_id</code>，當今天<code>stock_id</code>被傳進<code>function</code>中的時候，url就會隨著<code>stock_id</code>的不同，而出現不同的<code>url</code>所以我們就可以爬到不同的股票歷史股價！</p><p>既然我們已經寫好了此<code>function</code>，接下來就可以呼叫它，得到不同股票的歷史股價</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>上述程式碼，可以稍微優化一下，不要每次都要存取<code>file.csv</code>，我們利用<code>io.String</code>來做一個「虛擬」的檔案，而不是真的存在<code>file.csv</code>中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 舊的程式碼：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with open('file.csv', 'w') as f:</span></span><br><span class="line"><span class="comment">#     f.writelines(response.text)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># df = pd.read_csv('file.csv', index_col='Date', parse_dates=['Date'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新的程式碼：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">f = io.StringIO(response.text)</span><br><span class="line">df = pd.read_csv(f, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>] )</span><br></pre></td></tr></table></figure><br>這樣是不是簡潔很多呢！</p><h3 id="完整的程式碼"><a href="#完整的程式碼" class="headerlink" title="完整的程式碼"></a>完整的程式碼</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_price</span><span class="params">(stock_id)</span>:</span></span><br><span class="line">    now = int(datetime.datetime.now().timestamp())+<span class="number">86400</span></span><br><span class="line">    url = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/"</span> + stock_id + <span class="string">"?period1=0&amp;period2="</span> + str(now) + <span class="string">"&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line"></span><br><span class="line">    response = requests.post(url)</span><br><span class="line"></span><br><span class="line">    f = io.StringIO(response.text)</span><br><span class="line">    df = pd.read_csv(f, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>] )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h3 id="使用function"><a href="#使用function" class="headerlink" title="使用function"></a>使用function</h3><p>假如以後我們需要爬取不同的股票，例如「鴻海2354」，我們就可以寫：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = crawl_price(<span class="string">"2354.TW"</span>)</span><br><span class="line">df.Close.plot()</span><br></pre></td></tr></table></figure><br>就可以順利將鴻海的股票爬取下來喔！</p><center><img src="/Python新手教學2全球指數一次抓/2.png" title="歷史股價爬蟲鴻海"></center><p>接下來我們就來爬取世界上重要的指數吧！</p><h3 id="國際重要指數清單"><a href="#國際重要指數清單" class="headerlink" title="國際重要指數清單"></a>國際重要指數清單</h3><p>首先我們必須要爬取到國際重要指數清單，可以到以下網址來獲取：<br><a href="https://finance.yahoo.com/world-indices/" rel="external nofollow noopener noreferrer" target="_blank">https://finance.yahoo.com/world-indices/</a></p><center><img src="/Python新手教學2全球指數一次抓/3.png" title="yahoo國際指數"></center><p>接下來我們就可以將上述清單給手動複製起來？！<br>不，我們要用更炫的方法，當然是要用程式來爬呀：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://finance.yahoo.com/world-indices/"</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">f = io.StringIO(response.text)</span><br><span class="line">dfs = pd.read_html(f)</span><br><span class="line">world_index = dfs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>上述的程式碼，剛開始很簡單，就是用<code>requests.get</code>來獲取此網頁的資料，網頁中的資料都存在<code>response.text</code>中，跟之前一模一樣。</p><p>不過第5行有點不一樣，我們使用<code>io.StringIO(response.text)</code>將資料存成檔案<code>f</code><br>第6行，我們將此文件利用<code>pd.read_html(f)</code>來分析網頁<code>f</code>中的表格，將所有的表格存成 a list of dataframe<br>第7行，我們將第一張dataframe給拿出來。</p><center><img src="/Python新手教學2全球指數一次抓/4.png" title="國際指數清單"></center><p>這樣我們就有了此表格中的symbol和name，以供之後歷史股價的爬取</p><h3 id="最後，終於要爬取全球股價了！"><a href="#最後，終於要爬取全球股價了！" class="headerlink" title="最後，終於要爬取全球股價了！"></a>最後，終於要爬取全球股價了！</h3><p>萬事俱備！只欠東風，不過由於這次的教學已經很多了，所以大家可以自己練習看看，或是前往<a href="/Python新手教學3全球指數歷史數據/">下一個單元</a>，來爬取所有的歷史指數吧！</p><p>這一系列是我們影音課程的化簡版，<br>假如對此教程有興趣，歡迎點選下方影音課程，會豐富到炸裂喔～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我們已經知道怎麼抓取任意一檔股票歷史價格了，但有時候我們一次需要很多檔股票，怎麼辦呢？難道每個股票我們都要寫這麼多行，才能抓下來嗎？今天我們教你如何將上一次的功能包裝成 function，然後一次下載全球指數！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(0)為何用Python投資？</title>
    <link href="https://www.finlab.tw/Python%E6%96%B0%E6%89%8B%E6%95%99%E5%AD%B80%E7%82%BA%E4%BD%95%E7%94%A8Python%E6%8A%95%E8%B3%87/"/>
    <id>https://www.finlab.tw/Python新手教學0為何用Python投資/</id>
    <published>2019-02-05T10:24:05.000Z</published>
    <updated>2019-02-10T14:21:06.253Z</updated>
    
    <content type="html"><![CDATA[<p>你為什麼要用Python投資？Python投資有什麼好處？處在訊息萬千的時代中，如何不被淘汰？雖然本blog都一直在宣揚python，但是我們似乎漏掉了最重要的一點，「為何要用Python來投資」？那今天就讓我娓娓道來吧！</p><center><img src="/Python新手教學0為何用Python投資/thumbnail.png" title="全球股價爬蟲"></center><a id="more"></a><p>其實在2019年</p><h3 id="程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…"><a href="#程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…" class="headerlink" title="程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…"></a>程式化投資並不新奇，已經有各種解決方案，MT4、XQ、Multicharts…</h3><p>現在市面上已經充斥著很多的回測或量化系統了，像是以外匯為主的MT4、以股票為主的XQ、以期貨為主的Multicharts，然而這些系統雖然有其優點，然而我還是不會去使用它們，最主要的原因是</p><h3 id="雖然使用上輕鬆簡單，然而大部分是必須要付費的！"><a href="#雖然使用上輕鬆簡單，然而大部分是必須要付費的！" class="headerlink" title="雖然使用上輕鬆簡單，然而大部分是必須要付費的！"></a>雖然使用上輕鬆簡單，然而大部分是必須要付費的！</h3><p>以台灣最火紅的Multicharts和XQ全球贏家來說，最便宜的券商版，每個月需要額外花費1千元，要是你的總投資金額只有10萬，那每個月相當於損失1％的金額喔！也就是一年下來12％就白白花費了。</p><h3 id="MT4-不用錢呀，但程式碼複雜"><a href="#MT4-不用錢呀，但程式碼複雜" class="headerlink" title="MT4 不用錢呀，但程式碼複雜"></a>MT4 不用錢呀，但程式碼複雜</h3><p>MT4算是裡面非常佛心的軟體，下載歷史數據完全免費，而且還可以回測，但是缺點就是程式碼非常複雜，光是寫一個簡單的策略，就可以耗盡一個下午了。</p><p>這些軟體雖然都是寫代碼，但是有一個非常大的缺點，就是</p><h3 id="商用軟體自由度不夠"><a href="#商用軟體自由度不夠" class="headerlink" title="商用軟體自由度不夠"></a>商用軟體自由度不夠</h3><p>假如今天想要搭建機器學習的策略，那使用上述付費軟體其實是非常困難的，因為程式都已經包裝好了，可以用的語法就那些，沒辦法跟上近期華麗展開的AI產業。</p><p>另外，這些軟體在不同的商品上，各有所長，例如XQ針對股票、Multicharts針對期貨。但是缺乏一個更上層的資金控管系統，將所有的部位做一個有效的規劃。將多個策略整合，是有難度的。</p><p>究竟如何才能「不用花錢」、並享有「最新演算法」、又有最高的「自由度」呢？</p><h3 id="Python-與-R-程式語言崛起"><a href="#Python-與-R-程式語言崛起" class="headerlink" title="Python 與 R 程式語言崛起"></a>Python 與 R 程式語言崛起</h3><p>由於機器學習、資料科學的崛起，Python 與 R 是最大的受惠者！為何我覺得傳統的金融回測軟體幾乎都可以用 Python 與 R 來取代，原因在於：</p><h3 id="程式碼簡單、功能強大"><a href="#程式碼簡單、功能強大" class="headerlink" title="程式碼簡單、功能強大"></a>程式碼簡單、功能強大</h3><p>傳統開源的程式語言，如C++、Java，針對大量金融數據的函示庫比較少，通常得徒手寫，花非常多的時間。然而Python與R就是專門處理各種大量的資料，可以短短幾行代碼，就完成C++需要數百行的資料處理代碼。</p><p>於是 Python 與 R 在資料的處理上，雖然可能沒有比Multicharts 或 XQ 那麼簡單一兩行就撰寫策略，不過也相差不遠了（至少我自己的回測軟體已經化簡到到不相上下）。</p><h3 id="免費且開源"><a href="#免費且開源" class="headerlink" title="免費且開源"></a>免費且開源</h3><p>每個月省1000元，累積起來也不少！Python 與 R 除了程式語言是免費的以外，還有非常多機器學習演算法，也都是免費的！想要跑回測嗎？只要上網搜尋「backtest python github」，就可以撈到一堆開源回測項目來搭建！另外Python 與 R 都支援 dll 檔案，所以與券商的串接基本上是沒有問題的。<br>（Mac心碎）</p><h3 id="不只拿來交易"><a href="#不只拿來交易" class="headerlink" title="不只拿來交易"></a>不只拿來交易</h3><p>學了XQ、Multichart、MT4，就是拿來寫賺錢程式，但對於我來說，Python除了拿來投資，還有非常多的功能，不論是架設網站、平常寫一些小工具，或是求職，學會了 Python 或 R 絕對是只有加分不會扣分。</p><p>特別是Python已經是連續好幾年都是最熱門程式語言了，為何它不可撼動？因為大部分機器學習研究、產品研發，都會使用Python進行，簡單、快速、有效。R語言也不錯，有很多學術單位、金融研究單位也會使用R語言。不過以趨勢的熱門程度，以及package的豐富程度，我個人還是偏愛使用Python就是了。</p><p>新的一年不知道學什麼？就來學Python吧！<br>假如你喜歡做研究，而且覺得寫程式除了賺錢外，對你來說還有別的樂趣，那真的可以好好研究一下Python了！</p><p>這一系列文章將帶你從0開始，使用Python做投資！<br>下一單元，我們就來<a href="/用爬蟲爬全世界股價/">爬取股價資料</a>吧！</p><p>這一系列是我們影音課程的化簡版，<br>假如對此教程有興趣，歡迎點選下方影音課程，會豐富到炸裂喔～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你為什麼要用Python投資？Python投資有什麼好處？處在訊息萬千的時代中，如何不被淘汰？雖然本blog都一直在宣揚python，但是我們似乎漏掉了最重要的一點，「為何要用Python來投資」？那今天就讓我娓娓道來吧！&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/Python新手教學0為何用Python投資/thumbnail.png&quot; title=&quot;全球股價爬蟲&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>Python新手教學(1)用爬蟲爬全球股價!</title>
    <link href="https://www.finlab.tw/%E7%94%A8%E7%88%AC%E8%9F%B2%E7%88%AC%E5%85%A8%E4%B8%96%E7%95%8C%E8%82%A1%E5%83%B9/"/>
    <id>https://www.finlab.tw/用爬蟲爬全世界股價/</id>
    <published>2019-02-03T05:06:16.000Z</published>
    <updated>2019-02-10T14:22:45.510Z</updated>
    
    <content type="html"><![CDATA[<p>此方法可以爬全球股市！今天讓我們回到原點，從最簡單的程式開始教起，想要做股票數據分析，一定要先得到股票資料，所以我們就從股票資料如何獲取開始吧！</p><a id="more"></a><center><img src="/用爬蟲爬全世界股價/t.png" title="全球股價爬蟲"></center><h3 id="從頭開始學python"><a href="#從頭開始學python" class="headerlink" title="從頭開始學python"></a>從頭開始學python</h3><p>這篇文章將會是一系列的2019年新文章，我們會從初學者開始再從頭帶你瞭解python如何分析財經資料，並從中獲利！</p><p>是程式新手嗎？不用擔心，只要跟著這一系列的教學，保證你一定學的會！<br>這一系列教學將會是hahow課程中的化簡，但是可以幫助新手無痛的開始使用python！</p><p>以往我寫的分析都太複雜了，比較曲高和寡，常常嚇到大家，真的不好意思，就像衝太快，發現後面沒跟上，我們的初衷應該是讓更多人能接觸python，而不是將將大家甩在後頭XDDD。</p><h3 id="設定python環境"><a href="#設定python環境" class="headerlink" title="設定python環境"></a>設定python環境</h3><p>假如你還沒安裝python，可以先簡單的設定一下環境，我建議使用Anaconda，它一次就會幫你灌好不只是python，還有相關的套件，讓你可以無痛學習！</p><p>相關教學：<a href="/Python股票投資/">python環境安裝</a><br>按照上方文章教學，只要照著步驟，直到可以印出<code>hello world</code>為止，就趕快回來這邊喔！</p><p>有些人覺得Anaconda太笨重，且安裝太久，但我個人認為，對於新手來說極度的好用，所以還是非常建議你直接安裝，假如學習後發現想要更深入，再考慮其他的解決方案。</p><p>接下來，我們就可以開始用jupyter寫程式了！</p><h3 id="爬取歷史股價"><a href="#爬取歷史股價" class="headerlink" title="爬取歷史股價"></a>爬取歷史股價</h3><p>首先要先獲取股價資料，我們會用常用的package：requests<br>它可以將網路上的資料給下載下來，給程式使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>這邊的import就有點像是，我們打開某個套件的感覺，之後才能使用它。</p><p>我們想要爬取的網址，以台積電「2330」為例：<br><a href="https://query1.finance.yahoo.com/v7/finance/download/2330.TW?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0" rel="external nofollow noopener noreferrer" target="_blank">https://query1.finance.yahoo.com/v7/finance/download/2330.TW?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0</a><br>網址中的period1是指起始時間，而period2是指結束時間，其單位為1970的過了n秒，以上的網址，就可以將台積電在這兩個區間股價資訊給爬下來了！</p><p>但很奇怪的是，你直接用瀏覽器打開，沒有辦法用！<br>因為瀏覽器通常是用「get」的方法，<br>而此網址必須要用post方法，才能正確的得到資料。</p><h3 id="什麼是get和post呢？"><a href="#什麼是get和post呢？" class="headerlink" title="什麼是get和post呢？"></a>什麼是get和post呢？</h3><p>兩種都是電腦之間溝通的方式，你可以想像一種溝通是寫信、一種是打電話、一種是用line，無論哪一種，只要能夠溝通正確，就可以了！</p><p>如何使用post方法得到資料呢？可以用以下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site = <span class="string">"https://query1.finance.yahoo.com/v7/finance/download/2330.TW?period1=0&amp;period2=1549258857&amp;interval=1d&amp;events=history&amp;crumb=hP2rOschxO0"</span></span><br><span class="line">response = requests.post(site)</span><br></pre></td></tr></table></figure><p>這時，我們就會有一個<code>response</code>，裡面存放著台積電的歷史股價資訊，要怎麼把股價資訊打印出來呢？我們可以使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>來察看所有的文字檔</p><center><img src="/用爬蟲爬全世界股價/5.png" title="從網路上下載的文字檔"></center><h3 id="將資料存檔"><a href="#將資料存檔" class="headerlink" title="將資料存檔"></a>將資料存檔</h3><p>會發現此文字檔非常大…，所以我們希望能夠先將它存起來<br>下方的程式，就是將<code>response.text</code>的文字存入<code>file.csv</code>這個檔案之中，我們會先用<code>with</code>來確保<code>open(&#39;file.csv&#39;, &#39;w&#39;)</code>有被正確的執行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(response.text)</span><br></pre></td></tr></table></figure><br>為什麼檔案<code>file.csv</code>的格式要叫做<code>csv</code>呢？<br>是因為<code>csv</code>檔是一種可以用excel或記事本打開的格式。<br>例如我們以記事本打開如下：</p><center><img src="/用爬蟲爬全世界股價/4.png" title="記事本開啟file.csv"></center><h3 id="將資料讀進來"><a href="#將資料讀進來" class="headerlink" title="將資料讀進來"></a>將資料讀進來</h3><p>接下來我們重新把這個歷史資料讀進來，可以使用pandas這個套件，<br>pandas有點像是python版的excel，可以快速的對行列做運算，我們利用pandas的<code>read_csv</code>將csv檔給讀進來；並用<code>df.head()</code>印出前面五行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">'file.csv'</span>)</span><br><span class="line">print(df.head())</span><br></pre></td></tr></table></figure><center><img src="/用爬蟲爬全世界股價/3.png" title="將資料讀取出來"></center><p>我們會發現，此dataframe的column名稱很好，有開高低收，但是index卻是0,1,2,3…，而不是日期，我們必須將index換成日期，這樣之後在查找時，會比較方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># brfore:</span></span><br><span class="line"><span class="comment"># df = pd.read_csv('file.csv')</span></span><br><span class="line"><span class="comment"># after:</span></span><br><span class="line">df = pd.read_csv(<span class="string">'file.csv'</span>, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>])</span><br></pre></td></tr></table></figure><p>其中<code>index_col</code>就是將<code>Date</code>這條column當作是index，而<code>parse_dates</code>可以將<code>Date</code>轉換成程式瞭解的日期格式，而非單純的字串。</p><center><img src="/用爬蟲爬全世界股價/2.png" title="將資料更好的讀取出來"></center><p>上圖跟之前的就不一樣了喔！記得去比較一下～</p><p>這樣我們就簡單的得到了股價了！</p><h3 id="繪圖"><a href="#繪圖" class="headerlink" title="繪圖"></a>繪圖</h3><p>我們可以將收盤價的歷史紀錄給畫出來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.Close.plot()</span><br></pre></td></tr></table></figure><center><img src="/用爬蟲爬全世界股價/1.png" title="台積電歷史股價"></center><h3 id="全球股價"><a href="#全球股價" class="headerlink" title="全球股價"></a>全球股價</h3><p>你可以將任何一檔股價，包含美股港股台股陸股，用同樣的方式爬下來，只要在<a href="https://finance.yahoo.com/" rel="external nofollow noopener noreferrer" target="_blank">yahoo finance</a>可以找到，就一定可以下載的下來喔！</p><p>行有餘力，請點選<a href="/Python新手教學2全球指數一次抓/">下一單元</a>，我們就來抓全球股市指數吧！</p><p>這一系列是我們影音課程的化簡版，<br>假如對此教程有興趣，歡迎點選下方影音課程，會豐富到炸裂喔～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此方法可以爬全球股市！今天讓我們回到原點，從最簡單的程式開始教起，想要做股票數據分析，一定要先得到股票資料，所以我們就從股票資料如何獲取開始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="月營收" scheme="https://www.finlab.tw/tags/%E6%9C%88%E7%87%9F%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>論文導讀：利用MI-LSTM預測股價</title>
    <link href="https://www.finlab.tw/%E5%88%A9%E7%94%A8MI-LSTM%E9%A0%90%E6%B8%AC%E8%82%A1%E5%83%B9/"/>
    <id>https://www.finlab.tw/利用MI-LSTM預測股價/</id>
    <published>2019-01-09T07:13:01.000Z</published>
    <updated>2019-01-09T17:50:46.179Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章是2018年剛發表的paper，算是非常新但是滿有趣的方法，針對一般的股票建構一個預測隔日價格的LSTM模型，以下就是他的方法思路。</p><a id="more"></a><h3 id="動機"><a href="#動機" class="headerlink" title="動機"></a>動機</h3><p>股價預測一直都是非常熱門但具有挑戰性的機器學習題目，通常這類的文章不乏是使用各種的資訊，例如股價、技術指標、公司獲利、新聞資訊，並將這些資料餵給一些模型，例如 linear regression, SVM, 或是 NN 來預測未來股價。雖然這些方法被證實是可以使用的，但是預測能力不佳。因為當中有些資訊不但對於預測未來股價沒有幫助，反而會擾亂預測的準確度。</p><h3 id="此篇文章的貢獻"><a href="#此篇文章的貢獻" class="headerlink" title="此篇文章的貢獻"></a>此篇文章的貢獻</h3><p>這篇文章提出了 multi-input LSTM model，來使用額外的神經網路額外架構，從低相關連的資訊找出有價值的，並且濾掉不必要的雜訊。並且利用了額外的LSTM邏輯來建構「mainstream」的結構，並用「mainstream」所計算出來的資訊，來遺忘或記憶有用的資訊（gates）。此架構比原本的LSTM效果要更好。</p><h3 id="MI-LSTM"><a href="#MI-LSTM" class="headerlink" title="MI-LSTM"></a>MI-LSTM</h3><p>這是個特別針對金融股價預測所研發的架構，其原理是先找出想要預測的timeseries，並且找出N條高度正相關的timeseries（以股票而言，就可能是同類型的公司股價），還有N條最負相關的timeseries當作是此預測模型的輸入資料。有了這些資料後，下圖就是MILSTM的整體架構，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">Y</mi></mrow></mrow><annotation encoding="application/x-tex">\bold{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span></span> 是欲預測的股票的歷史股價，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mrow><mi mathvariant="bold">X</mi></mrow><mi>p</mi><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">\bold{X}_p^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:1.2077719999999998em;vertical-align:-0.383108em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf">X</span></span><span class="vlist"><span style="top:0.24700000000000003em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">p</span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 就是第 i 個高度正相關的timeseries，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mrow><mi mathvariant="bold">X</mi></mrow><mi>n</mi><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">\bold{X}_n^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:1.071664em;vertical-align:-0.247em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf">X</span></span><span class="vlist"><span style="top:0.247em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 就是高度負相關的 timeseries。最後 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="bold">X</mi></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bold{X}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf">X</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是大盤的 timeseries。</p><center><img src="/利用MI-LSTM預測股價/structure.jpg" title="structure"></center><p>上圖從左到右的解說如下</p><ul><li>LSTM：此圖中的最左邊部分，就是簡單的LSTM計算而已，假如想要知道什麼是LSTM，可以參考<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="external nofollow noopener noreferrer" target="_blank">這篇關於LSTM的詳細解說</a>。</li><li>Average：往右，可以看到高度正負相關的timeseries的LSTM，額外經過平均的運算，至於為什麼要這樣做，相信是效果比較好的緣故，當然實做時也可以拿掉、或是使用不一樣的的計算方式。</li><li><p>Multi-Input LSTM：而比較有趣的地方，在於其中紅色的Multi-Input LSTM這個部分，在於它像是一個變種的LSTM架構，多了很多的 gate（請參考LSTM文章來瞭解什麼是「gate」）。此MILSTM可以額外展開如下圖，可以發現跟一般的LSTM長的差不多，但是多了有顏色的三條資訊流，並且此三條資訊流都有額外的gates來篩選要儲存的資訊。</p><center><img src="/利用MI-LSTM預測股價/MIstructure.jpg" title="MILSTMstructure"></center></li><li><p>接下來是Attention Layer，其實跟LSTM原本的Attention是非常類似的，還是非常建議現瞭解<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" rel="external nofollow noopener noreferrer" target="_blank">LSTM是什麼</a>，不然到這邊你應該已經頭很昏了XD。</p></li></ul><p>實驗結果</p><p>這篇文章使用了300檔股票的歷史股價進行訓練，單一一檔的股票歷史資料一定不足，但是假如300檔串在一起，則樣本數應該就足夠了，既然都已經發了期刊，當然實驗結果要比別人好，所以以下是實驗的結果，當中的MSE就是誤差（mean square error）的意思：</p><center><img src="/利用MI-LSTM預測股價/table.jpg" title="與其他LSTM比較"></center><p>可以發現MI-LSTM獲得了最小的實驗誤差，相比起其它的model效果更好，而其它的model屬於LSTM的變形，這邊就先不介紹了。可以參考這篇LSTM文章。接下來，他們進一步分析了MI-LSTM中，每一類input的效果，種共有以下四類：</p><ol><li>Mainstream：欲預測的股票其歷史股價</li><li>Positive：高度正相關的一群股票</li><li>Negative：高度付相關的一群股票</li><li>Index：大盤</li></ol><p>下圖就是這四種不同的資訊流在神經網路中，通過softmax的時候的權重隨著訓練次數的變化：</p><center></center><p>最後可以發現Mainstream跟Index的資訊是最有效的，大盤對於股價的影響是非常大的，與投資時的狀況符合一致，大盤漲跌對於個股的影響很大。另外可以發現Positive跟Negative的權重被降低了，代表雖然這些資訊有很價值，但是當中也有很多的雜訊，所以權重被有效的分配。</p><h3 id="選股策略"><a href="#選股策略" class="headerlink" title="選股策略"></a>選股策略</h3><p>這篇文章提出了一種選股的策略，對於所有股票，都判斷明日的漲跌，並且每日選出漲跌最佳的20檔股票，不考慮手續費，可以得到以下每段時間的歷史報酬：</p><center><img src="/利用MI-LSTM預測股價/table2.jpg" title="歷史報酬"></center><p>可以看到MI-LSTM的效果比傳統的LSTM和大盤還要好，當然考慮了手續費後效果可能會打很多折扣，甚至是虧損。要是我的話，會想辦法增加預測時間的長度（但預測難度也可能會增加），從每天變成每個禮拜，這樣手續費可能比較不那麼誇張多。但我猜他們可能也有做過類似的實驗，但沒有成功？或是他們覺得這樣已經很好了？</p><p>實做上建議使用pytorch或是tensorflow會比較簡單，這篇文章只是簡單的介紹其架構，然而要寫程式的話，還是利用paper中的數學公式，會比直接看架構圖更好理解和實做，會比較好喔！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇文章是2018年剛發表的paper，算是非常新但是滿有趣的方法，針對一般的股票建構一個預測隔日價格的LSTM模型，以下就是他的方法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>Python：VIX美股大跌投資法</title>
    <link href="https://www.finlab.tw/Python%EF%BC%9AVIX%E7%BE%8E%E8%82%A1%E5%A4%A7%E8%B7%8C%E6%8A%95%E8%B3%87%E6%B3%95/"/>
    <id>https://www.finlab.tw/Python：VIX美股大跌投資法/</id>
    <published>2018-12-26T03:43:05.000Z</published>
    <updated>2018-12-26T21:47:03.379Z</updated>
    
    <content type="html"><![CDATA[<p>美股最近跌的慘慘慘，又到了聖誕假期，剛好又休市。我們當然趁現在來研究美股大跌時，要如何來投資，才是最佳的選擇呀！今天要介紹VIX，以及查看VIX如何幫助我們做美股長期投資。</p><center><img src="/Python：VIX美股大跌投資法/thumbnail.png" title="VIX"></center><a id="more"></a><h3 id="什麼是VIX"><a href="#什麼是VIX" class="headerlink" title="什麼是VIX"></a>什麼是VIX</h3><p>首先，究竟是什麼是VIX呢？VIX是一個預估12個月的波動程度，假如市場上的不確定因素越高，代表將來的股價會有非常高的不確定性，則VIX越高，假如市場普遍穩定，則VIX就會比較低。通常VIX大概會在15附近，當大家極度恐慌時（例如恐怖攻擊、金融海嘯等），VIX會急速跳動到30～50，然後再緩和下來。</p><p>更<a href="https://www.cboe.com/micro/vix/vixwhite.pdf" rel="external nofollow noopener noreferrer" target="_blank">嚴謹的數學公式</a>以連結的方式讓大家參考</p><p>於是有人就說可以參考VIX非常高的時候，當作是買點進行買入。<br>今天我們就用python來試試看是否有用？</p><h3 id="獲取歷史資料"><a href="#獲取歷史資料" class="headerlink" title="獲取歷史資料"></a>獲取歷史資料</h3><p>取得歷史資料的方式非常簡單，可以到「芝加哥期交所」官網來下載 <a href="http://www.cboe.com/products/stock-index-options-spx-rut-msci-ftse/s-p-500-index-options/s-p-500-index/spx-historical-data" rel="external nofollow noopener noreferrer" target="_blank">S&amp;P500歷史資料</a><br>還有<a href="http://www.cboe.com/products/vix-index-volatility/vix-options-and-futures/vix-index/vix-historical-data" rel="external nofollow noopener noreferrer" target="_blank">VIX歷史資料</a></p><p>將下載下來的csv檔放在資料夾中，就可以開始今天的實驗了！</p><h3 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h3><p>今天的教學主要分成以下幾個步驟</p><ol><li>利用pandas匯入csv檔資料</li><li>計算S&amp;P500的年報酬率，並繪圖</li><li>回測並檢討</li><li>稍微修改買入條件，並比較效果如何</li></ol><p>假如第一次接觸python的朋友，可以參考<a href="/Python股票投資/">python安裝教學</a>，安裝好之後就可以一起來玩囉！</p><p>接下來我們就來玩玩這些資料吧</p><h3 id="1-利用pandas匯入歷史資料"><a href="#1-利用pandas匯入歷史資料" class="headerlink" title="1. 利用pandas匯入歷史資料"></a>1. 利用pandas匯入歷史資料</h3><p>首先，我們可以使用<code>pd.read_csv()</code>這個函示來匯入歷史資料如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">vix = pd.read_csv(<span class="string">"vixcurrent.csv"</span>, header=<span class="number">1</span>, index_col=<span class="string">'Date'</span>, parse_dates=[<span class="string">'Date'</span>])</span><br><span class="line">vixc = vix[<span class="string">'VIX Close'</span>]</span><br></pre></td></tr></table></figure><center><img src="/Python：VIX美股大跌投資法/vix.png" title="VIX"></center><p>其中，<code>header=1</code>是指從第一行是column 的名稱。<code>index_col</code>是將指定的column轉換成index，最後，<code>parse_dates</code>是將指定的column轉換成datetime的格式。</p><p>再來，也是用類似的方法將SPX的指數給拿出來：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = pd.read_excel(<span class="string">"dailypricehistory.xls"</span>, header=<span class="number">4</span>)[<span class="string">'SPXSM'</span>]</span><br><span class="line">b.index = pd.to_datetime(bb.index, errors=<span class="string">"coerce"</span>)</span><br><span class="line">b = b.reindex(vixc.index)</span><br><span class="line">b = b.dropna()</span><br><span class="line">b.plot()</span><br></pre></td></tr></table></figure><center><img src="/Python：VIX美股大跌投資法/sp500.png" title="benchmark"></center><p>不過我們使用了一些額外的code，來稍微處理一下大盤指數，其中<code>b.dropna()</code>是將冗餘的資料去掉，另外，使用<code>b.reindex()</code>是因為，我們希望vixc跟b的長度是一樣的，每一天的index是對齊的。</p><h3 id="大盤歷史績效分析"><a href="#大盤歷史績效分析" class="headerlink" title="大盤歷史績效分析"></a>大盤歷史績效分析</h3><p>接下來我們希望可以分析美股SP500的年報酬指數，我們可以這樣寫：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(b.dropna()[<span class="number">-1</span>]/b[<span class="number">0</span>]) ** (<span class="number">250</span>/len(b))</span><br></pre></td></tr></table></figure></p><p>其實公式就是：</p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mo>(</mo><mfrac><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac><msup><mo>)</mo><mrow><mo>(</mo><mn>2</mn><mn>5</mn><mn>0</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mo>)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">r = (\frac{price_{end}}{price_{begin}}) ^ {(250 / ndays)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.907772em;"></span><span class="strut bottom" style="height:1.455852em;vertical-align:-0.5480799999999999em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mord mathrm">0</span><span class="mord mathrm">/</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mfrac><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow></msub></mrow><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">(\frac{price_{end}}{price_{begin}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.907772em;"></span><span class="strut bottom" style="height:1.455852em;vertical-align:-0.5480799999999999em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit">i</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.44610799999999995em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>就是總報酬率，但由於我們要算年報酬，還要進一步修改，ndays 就是所有的歷史報酬天數，其中的250是一年的交易日估算。</p><p>從下圖可以看出，大盤的平均年報酬率大概是6％左右。</p><center><img src="/Python：VIX美股大跌投資法/ann_ret.png" title="年報酬"></center><h3 id="VIX大於40，買入一年大盤能賺錢嗎？"><a href="#VIX大於40，買入一年大盤能賺錢嗎？" class="headerlink" title="VIX大於40，買入一年大盤能賺錢嗎？"></a>VIX大於40，買入一年大盤能賺錢嗎？</h3><p>接下來，我們來看當VIX大於40的當天，買入大盤並持有250天，會發生什麼事情呢：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vix 大於 th 時，進行買入</span></span><br><span class="line">th = <span class="number">40</span></span><br><span class="line"><span class="comment"># 持有 days 天</span></span><br><span class="line">days = <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 當天是否買入</span></span><br><span class="line">buy = (vixc &gt; th)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確保最近三十天並沒有buy發生，才是需要買入的訊號</span></span><br><span class="line">buy &amp;= (buy.shift().rolling(<span class="number">30</span>).mean() == <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最後一行值得一提，因為其實VIX大於40後，有時候會常常飆高，但其實我們是希望VIX突然飆高的第一天，而不是變低後39，然後又飆高到40以上，這種訊號不是我們需要的，所以利用上方的最後一行代碼進行過濾。</p><h3 id="繪圖"><a href="#繪圖" class="headerlink" title="繪圖"></a>繪圖</h3><p>將買點給畫出來：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.plot()</span><br><span class="line">buy.astype(float).plot(secondary_y=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><center><img src="/Python：VIX美股大跌投資法/buy1.png" title="買入點"></center><h3 id="報酬率計算"><a href="#報酬率計算" class="headerlink" title="報酬率計算"></a>報酬率計算</h3><p>接下來我們就來計算，當我們使用這個邏輯進行買賣時，效果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 當天收盤價</span></span><br><span class="line">price_begin = b[buy]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隔250天後 的收盤價</span></span><br><span class="line">price_end = b.shift(-days)[buy]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 報酬率計算</span></span><br><span class="line">ret = (price_end/price_begin)</span><br></pre></td></tr></table></figure><center><img src="/Python：VIX美股大跌投資法/return1.png" title="方法一報酬率"></center><p>我們可以發現報酬率滿不錯的，唯一一次沒有賺錢，是在2008年金融海嘯那次，我們可以將報酬率畫出來，方便大家理解</p><h3 id="持有250天的報酬率"><a href="#持有250天的報酬率" class="headerlink" title="持有250天的報酬率"></a>持有250天的報酬率</h3><p>接下來我們可以將這四次持有250天的大盤報酬曲線畫出來，橫軸為時間，會得到很有趣的結果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s / s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> ret.index.dropna():</span><br><span class="line">    plt.plot(normalize(b.loc[d:].head(<span class="number">250</span>).values))</span><br></pre></td></tr></table></figure></p><center><img src="/Python：VIX美股大跌投資法/eq1.png" title="報酬率時間圖"></center><p>這張圖中藍色的為金融海嘯，所以當買入時，還跌了一段，還是賠了40％的資產，非常的恐怖…。可見這種方法還是不能亂用。</p><p>另外更有趣的是，紅色跟藍色的大盤趨勢非常像，而綠色跟橘色也很類似，感覺大盤的變化隨時間是有規律的。</p><h3 id="優化策略"><a href="#優化策略" class="headerlink" title="優化策略"></a>優化策略</h3><p>接下來，我想要進行一個小修改，因為VIX是市場恐慌的程度，VIX高代表市場可能過於悲觀，但是不代表悲觀已經結束了，所以2008年的VIX才會噴到將近50左右的位置，所以我們不應該在VIX噴發時投資，應該要等它降溫時，投資會比較好，所以新的策略邏輯如下：</p><ol><li>VIX 近120天超過40</li><li>VIX 當天降到了30</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">th = <span class="number">40</span></span><br><span class="line">days = <span class="number">250</span></span><br><span class="line"></span><br><span class="line">buy = (</span><br><span class="line">    ((vixc &gt; th).rolling(<span class="number">120</span>).sum() &gt; <span class="number">0</span>) &amp;</span><br><span class="line">    (vixc &lt; <span class="number">30</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">buy &amp;= (buy.shift().rolling(<span class="number">30</span>).mean() == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">price_begin = b[buy]</span><br><span class="line">price_end = b.shift(-days)[buy]</span><br><span class="line">ret = (price_end/price_begin)<span class="comment">#.groupby(price_begin.index.year).first()</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><center><img src="/Python：VIX美股大跌投資法/method2.png" title="方法二的報酬率"></center><p>我們發現，這四次的買點都是有獲利的，且大於平均年報酬率(6％)，說明了這可能是比較好的投資方法。<br>然而取樣的點非常少，才4次，所以也有可能只是運氣好而已，過去不等於未來，投資風險就請大家自行斟酌囉！</p><p>相信大家可以用類似的方式，找到更好的投資方式喔！快來試試看吧～</p><center><img src="/Python：VIX美股大跌投資法/eq2.png" title="報酬率時間圖"></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美股最近跌的慘慘慘，又到了聖誕假期，剛好又休市。我們當然趁現在來研究美股大跌時，要如何來投資，才是最佳的選擇呀！今天要介紹VIX，以及查看VIX如何幫助我們做美股長期投資。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/Python：VIX美股大跌投資法/thumbnail.png&quot; title=&quot;VIX&quot;&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="美股" scheme="https://www.finlab.tw/tags/%E7%BE%8E%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>你錯過的選股策略！</title>
    <link href="https://www.finlab.tw/%E4%BD%A0%E9%8C%AF%E9%81%8E%E7%9A%84%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5%E6%80%9D%E8%B7%AF/"/>
    <id>https://www.finlab.tw/你錯過的選股策略思路/</id>
    <published>2018-12-18T23:45:46.000Z</published>
    <updated>2018-12-20T11:45:47.826Z</updated>
    
    <content type="html"><![CDATA[<p>一年前，我曾經跟大家分享一個<a href="/比策略狗還要安全的選股策略！/">懶人選股策略</a>，不知道各位有沒有看？看了後有沒有實做？實做了有沒有追蹤？追蹤了有沒有實際操作？假如以上答案都是「有」，那你目前應該獲利狀況不錯！假如沒有，這篇文章將帶你分析原因，並且分享「如何不再一次與獲利擦身而過」的方法。</p><a id="more"></a><p>我們先來看看「錯過」有多麼可怕！</p><h3 id="「錯過不是錯了，而是過了」"><a href="#「錯過不是錯了，而是過了」" class="headerlink" title="「錯過不是錯了，而是過了」"></a>「錯過不是錯了，而是過了」</h3><p>下圖中，橘紅色的為「加權指數」的歷史股價，而藍色的也是，差別在於藍色的股價剔除了10個一分鐘「最大漲幅」，來模擬一個人在14年中，除了有總共有10分鐘沒投資，其餘時間每天投資大盤，然而那10分鐘漲幅剛好非常大。</p><p>你可能會覺得結果應該差不多，但最後的結果，竟然有 50％ 的差距！</p><center><img src="/你錯過的選股策略思路/benchmark.png" title="錯過十分鐘漲幅的大盤"></center><p>這十分鐘就足以造成50％的差距，更何況一般人沒有紀律的投資了！<br>如此可見，錯過真的是非常可怕的一件事情！</p><h3 id="你錯過的一個策略"><a href="#你錯過的一個策略" class="headerlink" title="你錯過的一個策略"></a>你錯過的一個策略</h3><p>一年前，我介紹了一個<a href="/比策略狗還要安全的選股策略！/">策略</a>，這個策略屬於懶人投資，其歷史績效14年14倍，算是本blog滿早期的選股策略，其特色是，可以避開行情過熱的時段，它的特色是</p><h3 id="「假如你知道行情過熱，就休息個一年半載，放個長假」"><a href="#「假如你知道行情過熱，就休息個一年半載，放個長假」" class="headerlink" title="「假如你知道行情過熱，就休息個一年半載，放個長假」"></a>「假如你知道行情過熱，就休息個一年半載，放個長假」</h3><p>策略思路也滿清晰的，邏輯很簡單，我們現在就來看一下它今年的獲利狀況：</p><center><img src="/你錯過的選股策略思路/eq.png" title="此策略績效"></center><p>此策略今年大部分時間都沒有持股，反而是後期大跌之後，才開始持股，而且穩定勝過大盤！<br>雖然年漲幅只有9％，但相信已經勝過非常多的人，而且從十一月開始算，其實這個策略才執行了兩個月，每個月有4.5％，算是很不錯！</p><p>然而我相信，真正使用的人應該不多，甚至一隻手數的出來的那種，<br>因為就連我自己也沒有使用這個策略XD，接下來我們就來分析為什麼沒人用</p><h3 id="到底為什麼總是跟策略擦身而過？"><a href="#到底為什麼總是跟策略擦身而過？" class="headerlink" title="到底為什麼總是跟策略擦身而過？"></a>到底為什麼總是跟策略擦身而過？</h3><p>原因有很多層面，就跟切洋蔥一樣，依照每個人的等級不同，可能停留在不同的地方。先從最簡單的講起：</p><h3 id="1-不確定該策略的效果，不敢使用"><a href="#1-不確定該策略的效果，不敢使用" class="headerlink" title="1. 不確定該策略的效果，不敢使用"></a>1. 不確定該策略的效果，不敢使用</h3><p>這類的人應該是佔大多數，<br>畢竟當時finlab是個小部落格，而且網路名師多如牛毛。<br>假如沒有自己的驗證方法，早就已經眼花繚亂，<br>看完那篇文章，當下覺得有理，隔天就忘記。</p><p>這種應該可以篩掉80％的人了<br>剩下的20％呢？</p><h3 id="2-策略當時沒有篩選出股票，漸漸忘記"><a href="#2-策略當時沒有篩選出股票，漸漸忘記" class="headerlink" title="2. 策略當時沒有篩選出股票，漸漸忘記"></a>2. 策略當時沒有篩選出股票，漸漸忘記</h3><p>剩下的人20%，可能想試試看這個策略如何，<br>可惜的是，當時策略根本沒有持股，所以暫時將策略封存在倉庫，<br>看看之後什麼時候啟動，再開始追蹤，<br>然而過了好幾個月，就又忘記了</p><p>然而獲利是不等人的，這時候懊悔已經來不及</p><p>這20％的人在此時已經只剩5％</p><h3 id="3-追蹤了但是不敢使用"><a href="#3-追蹤了但是不敢使用" class="headerlink" title="3. 追蹤了但是不敢使用"></a>3. 追蹤了但是不敢使用</h3><p>接下來，就是這5％的人全軍覆沒的時候了XD<br>該策略竟然買在股市大跌的隔天，2018年10月11號當晚…<br>剛好是跌破近一年支撐線的隔天！<br>我也不敢使用XD</p><p>以上三種應該是大家最容易錯過策略，究竟要怎麼預防呢？</p><h3 id="如何不要錯過獲利？"><a href="#如何不要錯過獲利？" class="headerlink" title="如何不要錯過獲利？"></a>如何不要錯過獲利？</h3><p>我覺得要在多重策略上，建構一個更大的框架，在適當的時候更換策略，<br>但不是隨意更換策略，而是當某個條件發生的時候，才會更換，我回測過有效的方式是：</p><p>每隔一季或半年，挑選10日績效最強的三個策略，並將所有持股換成這三個策略的持股</p><p>用講的當然很容易，不過實行起來一定是有難度的。<br>以上只是我分享自己的看法，不知道你覺得如何？<br>歡迎下方留言分享你的「多策略搭配的方法」喔！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年前，我曾經跟大家分享一個&lt;a href=&quot;/比策略狗還要安全的選股策略！/&quot;&gt;懶人選股策略&lt;/a&gt;，不知道各位有沒有看？看了後有沒有實做？實做了有沒有追蹤？追蹤了有沒有實際操作？假如以上答案都是「有」，那你目前應該獲利狀況不錯！假如沒有，這篇文章將帶你分析原因，並且分享「如何不再一次與獲利擦身而過」的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="選股策略" scheme="https://www.finlab.tw/categories/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="如何買股票" scheme="https://www.finlab.tw/tags/%E5%A6%82%E4%BD%95%E8%B2%B7%E8%82%A1%E7%A5%A8/"/>
    
      <category term="選股策略" scheme="https://www.finlab.tw/tags/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
      <category term="歷史回測" scheme="https://www.finlab.tw/tags/%E6%AD%B7%E5%8F%B2%E5%9B%9E%E6%B8%AC/"/>
    
      <category term="本益比" scheme="https://www.finlab.tw/tags/%E6%9C%AC%E7%9B%8A%E6%AF%94/"/>
    
      <category term="股價淨值比" scheme="https://www.finlab.tw/tags/%E8%82%A1%E5%83%B9%E6%B7%A8%E5%80%BC%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>Python：免費加速度指標選股實做</title>
    <link href="https://www.finlab.tw/%E5%8A%A0%E9%80%9F%E5%BA%A6%E6%8C%87%E6%A8%99%E5%AF%A6%E5%81%9A/"/>
    <id>https://www.finlab.tw/加速度指標實做/</id>
    <published>2018-12-17T05:49:03.000Z</published>
    <updated>2018-12-17T15:38:55.388Z</updated>
    
    <content type="html"><![CDATA[<p>今天終於要來介紹加速度指標，這個指標的用處，在於可以篩選出「止跌回升」或「加速往上漲」的股票，經過<a href="/加速度指標-加速你的獲利">回測驗證</a>是有效的。搭配其他指標，可以獲得約20％的年報酬率。接下來我們就來用 python 實做它吧！</p><center><img src="/加速度指標實做/thumbnail.png" title="時間序列dataframe"></center><p>這個 blog 會永久推出免費的教學，讓大家可以免費的學習 python 又賺錢，學習程式語言是很多人憧憬的目標，但是常常會有學了不知道拿來做什麼？要是寫程式不只能在工作上增加效率，還能幫你挑股票賺錢，那還有什麼理由不學習呢？</p><p>我喜歡寫程式，也希望可以做出很好的工具，幫助到大家，帶著這個初衷，我創立了finlab 並且持續到了現在（不過中間因為博士班論文所以暫停了一段時間）。與其販賣選股軟體，我們分享代碼，讓大家自己零成本 DIY，假如想要支持我們，可以考慮我們的<a href="https://hahow.in/cr/python-finance" rel="external nofollow noopener noreferrer" target="_blank">影音課程</a>，獲得完整的 python 選股知識跟大量實用代碼。</p><p>好了廢話不多說，開始今天的 python 程式碼吧！</p><h3 id="製作時間序列"><a href="#製作時間序列" class="headerlink" title="製作時間序列"></a>製作時間序列</h3><p>首先我們必須先做出時間序列，時間序列其實就是一條條股價隨時間的變化圖，有點像是K線圖，我們習慣將這些資料整理成以下的樣貌：</p><center><img src="/加速度指標實做/close.png" title="時間序列dataframe"></center><p>要如何獲得此資料結構呢？</p><ol><li>假如您沒有購買課程的話，可以參考<a href="/Python-時間序列實作！">這篇文章來免費獲得時間序列資料</a>，調整當中的參數，獲得至少200天的收盤價喔！</li><li>假如您已經有課程中的代碼，就變得很簡單，只需要：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> finlab.data <span class="keyword">import</span> Data</span><br><span class="line">data = Data()</span><br><span class="line"></span><br><span class="line">close = data.get(<span class="string">'收盤價'</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>就可以獲得兩百天內的所有上市股價資料。</p><p>在這個階段完成後，我們會有一個 <code>close</code> 的 variable，裡面的資料結構就如上圖一樣，是一個 <code>dataframe</code> 而其中就是一條條時間序列，每一檔股票的收盤價。</p><h3 id="撰寫加速度指標"><a href="#撰寫加速度指標" class="headerlink" title="撰寫加速度指標"></a>撰寫加速度指標</h3><p>加速度指標的原理，可以參考</p><ul><li><a href="/簡易的外資-基本面策略/">加速度指標解說</a></li><li><a href="/加速度指標-加速你的獲利">加速度指標回測</a></li></ul><p>簡單來說，加速度指標，其實就是看均線的曲率是正負，來決定是否買賣，但是由於股價的雜訊太大了，與其用微分的，我們提供一個比較簡單的方式，來判斷曲率的正負：</p><p>(n天前 + 當天)/2 &gt; n/2天前 的k天均線</p><p>我們把以上這個判斷式寫成代碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">close60 = close.rolling(<span class="number">60</span>, min_periods=<span class="number">10</span>).mean()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rising_curve</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (close60.iloc[-n] + close60.iloc[<span class="number">-1</span>]) / <span class="number">2</span> &gt; close60.iloc[-int((n+<span class="number">1</span>)/<span class="number">2</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的代碼中，第一行，我們創建了<code>close60</code>這個<code>variable</code>，裡面的資料就是每檔股票60天的均線的數值。</p><p>接下來，在第三行中，我們定義了一個<code>function</code>叫做<code>rising_curve</code>，來判斷條件是否符合，<br>第四行，就是最重要的判斷式：</p><p>其中我們只用到了<code>iloc(k)</code>這個<code>method</code>，這個<code>method</code>是將<code>close60</code>中第<code>k</code>條<code>row</code>給拿出來的意思。而<code>k</code>可以是正的，代表從<code>dataframe</code>的第0條row開始數，也可以是負的，代表從 <code>dataframe</code>的最後一條row倒著數。</p><h3 id="試用看看"><a href="#試用看看" class="headerlink" title="試用看看"></a>試用看看</h3><p>接下來我們就可以呼叫這個rising_curve，來看哪些股票符合這個條件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rising_curve(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br>以上這行就是判斷10日內的取率是多少，會得出以下的結果：</p><center><img src="/加速度指標實做/rising_curve.png" title="獲得符合條件的股票"></center><p>代表哪些檔股票符合條件，而哪些不符合條件。</p><h3 id="組裝策略"><a href="#組裝策略" class="headerlink" title="組裝策略"></a>組裝策略</h3><p>接下來就到了多個策略組合的時候了，<a href="/加速度指標-加速你的獲利">前一篇文章</a>有說過，必須要用多次的rising_curve來判斷不同週期下，是否都是符合條件！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rising = (</span><br><span class="line">    rising_curve(<span class="number">5</span>) &amp;</span><br><span class="line">    rising_curve(<span class="number">10</span>) &amp; </span><br><span class="line">    rising_curve(<span class="number">20</span>) &amp;</span><br><span class="line">    rising_curve(<span class="number">60</span>) &amp;</span><br><span class="line">    rising_curve(<span class="number">30</span>) &amp;</span><br><span class="line">    rising_curve(<span class="number">40</span>) &amp;</span><br><span class="line">    rising_curve(<span class="number">50</span>) &amp;</span><br><span class="line">    (close.iloc[<span class="number">-1</span>] &gt; close60.iloc[<span class="number">-1</span>])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(rising[rising])</span><br></pre></td></tr></table></figure><p>以上，第2～9行，我們將所有的條件做交集（&amp;），代表必須要全部的條件都符合，才能被選入清單，我們以非常嚴苛的方式，來判斷股價的曲率。<br>最後一行，我們使用<code>rising[rising]</code>，這個意思是，從<code>rising</code>這條序列中，選取<code>rising</code>為 <code>True</code>的股票，忽略<code>False</code>的股票。</p><p>最後得出了一串清單，代表符合所有條件的股票代號：</p><center><img src="/加速度指標實做/and.png" title="獲得符合條件的股票"></center><h3 id="選股個股概覽"><a href="#選股個股概覽" class="headerlink" title="選股個股概覽"></a>選股個股概覽</h3><p>我們將選出來的股票畫出來，來瞭解這些股票的特性，下圖中，黃色的為股價，而藍色的為均線，我們可以發現這些股票的特性，就是均線會呈現圓弧型：</p><center><img src="/加速度指標實做/stocks.png" title="符合條件的股票"></center><p>可以看到大部分都是抓出止跌回漲的股票居多，加速度指標可以抓出兩種股票：</p><ol><li>止跌</li><li>起漲<br>至於要更細部的設定，就留給各位看官來實做了。</li></ol><p>假如將以上代碼的不等式反過來用，也可以抓出股票的賣點，進而抓出止漲的股票，我發現加速度指標拿來抓賣點，搭配一些技術指標效果非常好，可以試試看！</p><h3 id="今天的重點整理"><a href="#今天的重點整理" class="headerlink" title="今天的重點整理"></a>今天的重點整理</h3><ol><li>加速度指標實做</li><li>利用「iloc」選取特定的row</li><li>利用「&amp;」來做條件交集，篩選股票</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天終於要來介紹加速度指標，這個指標的用處，在於可以篩選出「止跌回升」或「加速往上漲」的股票，經過&lt;a href=&quot;/加速度指標-加速你的獲利&quot;&gt;回測驗證&lt;/a&gt;是有效的。搭配其他指標，可以獲得約20％的年報酬率。接下來我們就來用 python 實做它吧！&lt;/p&gt;
&lt;cen
      
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="簡易策略" scheme="https://www.finlab.tw/tags/%E7%B0%A1%E6%98%93%E7%AD%96%E7%95%A5/"/>
    
      <category term="選股策略" scheme="https://www.finlab.tw/tags/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
      <category term="歷史回測" scheme="https://www.finlab.tw/tags/%E6%AD%B7%E5%8F%B2%E5%9B%9E%E6%B8%AC/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>ROE怎麼看?機器學習告訴你</title>
    <link href="https://www.finlab.tw/ROE%E6%80%8E%E9%BA%BC%E7%9C%8B-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E5%91%8A%E8%A8%B4%E4%BD%A0/"/>
    <id>https://www.finlab.tw/ROE怎麼看-機器學習告訴你/</id>
    <published>2018-12-11T08:49:55.000Z</published>
    <updated>2018-12-13T17:03:42.895Z</updated>
    
    <content type="html"><![CDATA[<p>機器學習究竟能不能輔助人類買賣股票？答案一定是可以的，我們可以藉由機器學習歸納出結果，來優化我們的選股方式，今天這篇文章沒有非常高深的數學，也沒有困難的程式，只會有做完研究的心得，幫助大家選股更順利！<br><a id="more"></a></p><center><img src="/ROE怎麼看-機器學習告訴你/thumbnail.png" title="SVM教你怎麼選股"></center><p>這篇文章中，我把市值跟ROE拿來做比較，並且利用SVM來訓練判斷，<br>看看市值跟ROE對於股價漲跌的關連</p><h3 id="什麼是SVM？"><a href="#什麼是SVM？" class="headerlink" title="什麼是SVM？"></a>什麼是SVM？</h3><p>SVM的全名叫做 <a href="https://en.wikipedia.org/wiki/Support_vector_machine" rel="external nofollow noopener noreferrer" target="_blank">Support Vector Machine</a>，而這類的機器學習，會用 hyperplane 將空間切開，進而將空間中的座標進行分類，所以當我們有2個features時，就可以將第一個feature當作 x 軸，第二個 feature 當作 y 軸，然後顏色代表漲跌，畫出一張圖：</p><center><img src="/ROE怎麼看-機器學習告訴你/svm.png" title="svm的簡單範例"></center><p>其中的綠色點，就是代表下跌的股票，而紅色的點，則代表了上漲的股票，而hyperplane 就是黃色的時線，將這個平面上畫出精準的一刀，切成兩個部分，右半部份，代表SVM覺得未來會上漲，左半部份代表SVM覺得未來會下跌的股票。</p><p>以上是由視覺的方式來說明SVM，數學的部分，其實大家國中高中都有學過，其實就是點與 hyperplane 的長度，SVM會計算「點到線」之間的長度，來決定誤差。當有越多點歸類錯誤的時候，SVM就會將這些「點到線的距離加總」，當作是錯誤總分，越大越不好，於是演算法不斷的移動這個切割線（hyperplane），來達到最完美的狀態，使得錯誤總分最低。</p><h3 id="SVM-的-Kernel-Trick"><a href="#SVM-的-Kernel-Trick" class="headerlink" title="SVM 的 Kernel Trick"></a>SVM 的 Kernel Trick</h3><p>我們上述的都是一條直線的 hyperplane ，但其實它不一定得是直的，只要能夠切分出不同的區域來分類即可。下圖就是使用linear的kernel跟曲線的kernel的範例：</p><center><img src="/ROE怎麼看-機器學習告訴你/kernel.png" title="不同的kernel結果也不一樣"></center><p>接下來，我們就來使用不同的kernel，來將股票做歸類，看它們究竟會上漲還是下跌？<br>我們所使用的 features 只有：<br>ROE、市值<br>方便我們以圖形化的方式呈現並理解，以下是結果</p><h3 id="使用線性的kernel"><a href="#使用線性的kernel" class="headerlink" title="使用線性的kernel"></a>使用線性的kernel</h3><p>此時 hyperplane 就是很簡單的一條線。雖然是簡單的一條線，但它還是非常有用處，我們可以藉由這條線的斜率，來瞭解 ROE 跟市值的關係：</p><center><img src="/ROE怎麼看-機器學習告訴你/linear.png" title="linearKernel成果"></center><p>程式自動最佳化後，上圖就是程式找到一刀最完美的切法，</p><ul><li>黃色三角形為上漲的股票</li><li>藍色正方形為下跌的股票</li><li>黃色平面是SVM認為會上漲的股票</li><li>藍色平面是SVM認為會下跌的股票</li></ul><p>這邊的市值跟ROE都已經經過preprocessing，所以跟我們平常看到的數值不太一樣，<br>我們由上圖可以看出程式在想什麼：</p><h4 id="機器學習：市值越高的股票，ROE也要越高"><a href="#機器學習：市值越高的股票，ROE也要越高" class="headerlink" title="機器學習：市值越高的股票，ROE也要越高"></a>機器學習：市值越高的股票，ROE也要越高</h4><p>可以看到上圖中，斜率是正的，代表當市值越高時，SVM 會傾向於選擇 ROE 高一點的股票，而且此條線偏上方，代表ROE比較高比較好，所以我們可以做一些歸納；</p><h4 id="假如有一檔股票「市值高，但是ROE低」，不會被選進來"><a href="#假如有一檔股票「市值高，但是ROE低」，不會被選進來" class="headerlink" title="假如有一檔股票「市值高，但是ROE低」，不會被選進來"></a>假如有一檔股票「市值高，但是ROE低」，不會被選進來</h4><p>這樣的想法算滿合理的，因為大家對市值高的股票期望比較高，或是公司的規模比較大，但此公司坐擁資源竟然還沒辦法為股東賺錢，於是期望可能轉換為失望，所以SVM表示看跌。</p><p>當然這個理由是我自己加的，SVM 是無情的最佳化結果而已。<br>另外我們也可以看到：</p><h4 id="對於「市值低，ROE低」的公司，SVM會比較寬容"><a href="#對於「市值低，ROE低」的公司，SVM會比較寬容" class="headerlink" title="對於「市值低，ROE低」的公司，SVM會比較寬容"></a>對於「市值低，ROE低」的公司，SVM會比較寬容</h4><p>一檔「市值低，ROE低」的公司，SVM會比較寬容一些些（但還是有一定的門檻）只是不如市值高的公司那麼嚴苛罷了。</p><p>我們來看一下以此種邏輯回測的結果，紅色為預測會漲的股票，綠色為預測會跌的股票，每季獲利的平均</p><center><img src="/ROE怎麼看-機器學習告訴你/eq1.png" title="回測結果"></center><p>效果很不錯<br>但是這個邏輯是否是完美的呢？<br>我們再來使用不同的kernel，試試看</p><h3 id="使用曲線的kernel"><a href="#使用曲線的kernel" class="headerlink" title="使用曲線的kernel"></a>使用曲線的kernel</h3><p>下圖為使用不同的kernel，所做出來的分類結果，我們使用2次多項式來對股票進行分類</p><center><img src="/ROE怎麼看-機器學習告訴你/poly.png" title="回測結果"></center><p>怎麼分出來完全不一樣呀！我們來看第二個實驗，SVM又告訴了我們什麼：</p><h4 id="市值高的股票-ROE-不要太高"><a href="#市值高的股票-ROE-不要太高" class="headerlink" title="市值高的股票 ROE 不要太高"></a>市值高的股票 ROE 不要太高</h4><p>這其實還是有些道理的，ROE 太高的股票不要買，這個是很多實驗都有做出來的結果，因為大公司的獲利，好歹也是龐大而穩定的系統，ROE高是會有上限的，不可能一直成長，當今天ROE已經很高時，代表接下來不會更高了，甚至還有可能會衰退。</p><p>所以買市值高的股票時，SVM傾向「ROE 不要太高」</p><h4 id="市值低的股票-ROE-越高越好"><a href="#市值低的股票-ROE-越高越好" class="headerlink" title="市值低的股票 ROE 越高越好"></a>市值低的股票 ROE 越高越好</h4><p>然而本實驗的另一個特點，就是SVM統計出來，發現市值低的股票ROE高是沒有關係的，至於原因可能是因為，市值低的股票，大家對於該公司期望並不高，在此狀況下，高 ROE 的數值跌破大家的眼鏡，所以造成長期的後市看好。（只是推測）</p><p>所以買市值低的股票時，SVM傾向「ROE 盡量高一點」 </p><h4 id="市值中間的股票，不要買"><a href="#市值中間的股票，不要買" class="headerlink" title="市值中間的股票，不要買"></a>市值中間的股票，不要買</h4><p>這個條件是最詭異的一個，我還是不要亂解釋好了XDD。</p><h3 id="回測結果"><a href="#回測結果" class="headerlink" title="回測結果"></a>回測結果</h3><p>這樣的邏輯可以獲利嗎？我們可以看以下的結果，紅色為持有預測會漲的股票，綠色為持有預測會跌的股票，每季獲利的平均：</p><center><img src="/ROE怎麼看-機器學習告訴你/eq2.png" title="回測結果"></center><p>也是有不錯的獲利！<br>利用 SVM 來分辨漲跌的股票，真的還滿有趣的，本文利用了兩種不同的 kernel：</p><ul><li>linear</li><li>polynomial<br>來進行分類，結果顯示 linear 的分類，跑出來的回測獲利比較優秀，但由這兩種不同的kernel，製作出來的模型，都可以拿來獲利。</li></ul><p>雖然兩個模型的闡述「相互矛盾」「有點道理、但又有點詭異」<br>就像是投資界眾說紛紜的理論一樣，<br>所以以後看到相互矛盾的論點，<br>其實不一定誰好誰壞，甚至說不定都能夠獲利，<br>這就是股票市場的有趣之處。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;機器學習究竟能不能輔助人類買賣股票？答案一定是可以的，我們可以藉由機器學習歸納出結果，來優化我們的選股方式，今天這篇文章沒有非常高深的數學，也沒有困難的程式，只會有做完研究的心得，幫助大家選股更順利！&lt;br&gt;
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>用Machine learning 學習看技術指標</title>
    <link href="https://www.finlab.tw/Machine-learning%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8A%80%E8%A1%93%E6%8C%87%E6%A8%99%E9%A0%90%E6%B8%AC%E5%A4%A7%E7%9B%A4/"/>
    <id>https://www.finlab.tw/Machine-learning：使用技術指標預測大盤/</id>
    <published>2018-12-04T15:58:25.000Z</published>
    <updated>2018-12-13T17:15:58.926Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.sciencedirect.com/science/article/pii/S0957417414004473" rel="external nofollow noopener noreferrer" target="_blank">這篇文章是印度指數預測</a>，2015年發表的就能有191個citation，算是很有名的paper之一，全文特點是只使用了技術指標，來預測大盤每天漲跌，提出了一個有效的優化方式。</p><center><img src="/Machine-learning：使用技術指標預測大盤/thumbnail.png" title="技術指標機器學習"></center><p>這篇paper的作者非常的認真，總共訓練四種不同的模型：Artificial Neural Network (ANN), support vector machine (SVM), random forest (RF) 和 Naive-Bayes (NB)。</p><p>這邊假如看不懂沒有關係，可以想像「模型」就是「電腦的大腦」，負責學習每種指標怎麼對應到未來的漲跌。之後有空再來慢慢介紹這些不同的「大腦」背後的數學原理。</p><p>此論文主要建構製作兩組traning data：</p><ul><li>包含十種技術指標</li><li>為這十種技術指標的看漲看跌<br>前者為 float （被normalize成-1～1）<br>而後者為 boolean （也就是只有輸入True和False）。</li></ul><p>究竟這些排列組合會迸出什麼樣的火花呢？</p><h3 id="選擇模型"><a href="#選擇模型" class="headerlink" title="選擇模型"></a>選擇模型</h3><p>研究發現Random Forest的表現是最好的，而ANN差了一點，<br>這是滿正常的，畢竟data set還是太小，神經網路很難訓練的非常好。<br>至於傳統的NB則是最差的。</p><p>其實也可以考慮一下LSTM，說不定效果也不錯？<br>（但因為LSTM還是基於ANN，所以有可能遇到traning set太小的問題）</p><h3 id="選擇traning-data"><a href="#選擇traning-data" class="headerlink" title="選擇traning data"></a>選擇traning data</h3><p>如同上面所述，此篇論文總共先用了十種技術指標，以下是這十種常見的指標，為了讓文章不會太冗長，我就不一一解釋了，之後有空再來介紹每種指標的用法。</p><center><img src="/Machine-learning：使用技術指標預測大盤/p1.png" title="十種技術指標"></center><p>￼<br>這篇paper會將這些技術指標的數值，每一項做normalize在-1～1之間，這樣的優化主要是為了ANN和SVM。以下是這個model的架構：</p><center><img src="/Machine-learning：使用技術指標預測大盤/p2.png" title="最初的架構"></center><p>￼<br>另外，全文的特點是使用了提出了 「Trend Deterministic Data Preparation」，看起來非常的厲害，簡單講就是將這些指標的數值究竟是「看漲」還是「看跌」拿來訓練，而不是訓練指標本身的數值。</p><p>例如均線好了，與其拿均線的值來訓練，不如看「股價跟均線的關係」，假如股價在均線之上，就是「看漲」（True），反之則「看跌」（False）。其他指標都能以此類推！</p><p>以下就是新增了一層資料的修改的架構：</p><p><center><img src="/Machine-learning：使用技術指標預測大盤/p3.png" title="優化後的架構"></center><br>￼</p><p>最後發現使用了「Trend Deterministic Data Preparation」<br>效果好很多！</p><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>這篇文章中，可以大概知道每一種model對於技術性指標的數據的效果如何。並且了解了用「Trend Deterministic Data Preparation」來進行優化。經過了非常多參數的比對，發現使用RF model做出來的策略效果最好。然而這只限於頻率為「天」的股價，假如頻率不是「天」，則可能會不一樣～。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0957417414004473&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>機器學習-總體經濟</title>
    <link href="https://www.finlab.tw/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E7%B8%BD%E9%AB%94%E7%B6%93%E6%BF%9F/"/>
    <id>https://www.finlab.tw/機器學習-總體經濟/</id>
    <published>2018-11-27T08:53:00.000Z</published>
    <updated>2018-11-29T17:06:44.861Z</updated>
    
    <content type="html"><![CDATA[<p>今天<a href="https://pdfs.semanticscholar.org/b68e/8d2f4d2c709bb5919b82effcb6a7bbd3db37.pdf" rel="external nofollow noopener noreferrer" target="_blank">這篇paper</a>是介紹總體經濟，現在全球的經濟是連動的，例如中美貿易大戰影響到全球股價，金價油價對於美國股市也有很大的影響，今天這篇paper就是要來研究不同的指數，對於NASDAQ指數的影響。</p><p>這篇文章利用美股開盤前的所有重要指數，例如油價、貴金屬價格、以及全球股市的對於美股的影響，既然全球市場是連動的，那這其中必定有一些關聯，下圖就是這篇paper所使用的重要指數：</p><center><img src="/機器學習-總體經濟/data.png" title="本文所用到資料"></center><h3 id="建構features"><a href="#建構features" class="headerlink" title="建構features"></a>建構features</h3><p>這篇文章想要找出股價的趨勢，而不是絕對數值，所以其features除了股價外，也有一段時間股價的變化，這邊先叫做window size w，並且對於價格的變化進行normalize。</p><h3 id="分析features"><a href="#分析features" class="headerlink" title="分析features"></a>分析features</h3><p>我覺得本文值得讚許的地方在於有提供一些簡單的方法做features的分析，可以由這些方法知道哪些features對於預測是非常有幫助的！</p><p>論文中使用了cross correlation來分析各種不同商品的價格對於NASDAQ影響。要說明cross correlation，就要先從correlation說起，correlation是兩種不同的數據，其相關性的係數。correlation介於-1到1之間，分別代表這兩種時間序列之間的關聯性：</p><ul><li>correlation = -1：代表數據完全負相關，也就是A漲B就跌的概念</li><li>correlation = 0：代表數據之間沒什麼關聯，也就是A漲跌跟B漲跌完全沒關係</li><li>correlation = +1：代表數據之間是正相關，也就是AB同漲同跌的關係</li></ul><p>那「cross」又是什麼意思呢？就是將兩組時間序列的時間錯開，差N天，並且觀察其correlation。</p><p>下圖就是所有的商品對於NASDAQ的cross correlation 分析，X軸就是差N天的N，而Y軸就是correlation，可以看到，在X = 0 時，NASDAQ跟NASDAQ的相關性是1，代表NASDAQ與自己的指數完全正相關，而很多商品都會在N = 0時有正相關性！</p><center><img src="/機器學習-總體經濟/crosscorrelation.png" title="auto-correlation"></center><p>所以我們使用N = 0來預測NASDAQ的股價會是最好的，但是N = 0的資料是沒有辦法使用的，因為你不能在當天的開盤就知道NASDAQ的收盤價，這樣就代表用到未來數據了。</p><p>所以我們只能退而求其次，用 N &lt; 0 的資料，也就是前N天的資料，我們可以發現N = -1的地方有一點小突起，代表某些資料對於NASDAQ的correlation也是很高的，可以拿來利用！</p><p>唯一想吐槽的是這張圖很多顏色都重複，所以根本看不太清楚是哪些商品，拿來預測NASDAQ比較準。</p><h3 id="三個維度的-cross-correlation"><a href="#三個維度的-cross-correlation" class="headerlink" title="三個維度的 cross-correlation"></a>三個維度的 cross-correlation</h3><p>另外，這篇paper也提供了不同股價區間差w對於漲跌的correlation：</p><center><img src="/機器學習-總體經濟/crosscorrelation3d.png" title="auto-correlation"></center><p>可以發現商品價格與NASDAQ股價之間是有一定的關係的，假如商品之間彼此沒有關聯，這張圖就不會呈現三角形的山丘狀，而是會看起來像是隨機的樣子。</p><p>上面這張圖說明了一件事情，股價變化越長時間來觀察(w 越長)，NASDQL跟許多商品的前一天的correlation是越高的，可以藉由提高精準度！</p><p>藉由上述的兩個實驗，我們知道股價變化量的重要性，重點不是股價本身，而是股價的漲跌幅度才有辦法更好的預測股價～</p><p>除此之外，作者想要進一步知道哪些時間序列對於NASDQL是重要的，所以進行了一個簡單的預測實驗</p><h3 id="預測明天的價格"><a href="#預測明天的價格" class="headerlink" title="預測明天的價格"></a>預測明天的價格</h3><p>作者也利用每一個單一序列當作單一feature，來預測隔天的漲跌，發現利用DAX這個時間序列來預估NASDQL會得到最好的結果：</p><center><img src="/機器學習-總體經濟/importance.png" title="features的重要性"></center><p>作者並沒有說這邊的model是哪一種，我猜應該是SVM，因為feature_size很小。<br>這樣我們就可以找到比較重要跟不重要的時間序列，之所以要這樣是因為此篇paper有用SVM當作model，而SVM比較適用於小feature_size的traning set。</p><h3 id="預測N天後的價格"><a href="#預測N天後的價格" class="headerlink" title="預測N天後的價格"></a>預測N天後的價格</h3><p>除了每天的價格外，此paper也研究K天後的價格漲跌，發現K越大，則預測的能力越好，下圖中 K 為 x 軸</p><center><img src="/機器學習-總體經濟/multiple_day.png" title="預測多天後的漲跌"></center><h3 id="測試-w-的大小"><a href="#測試-w-的大小" class="headerlink" title="測試 w 的大小"></a>測試 w 的大小</h3><p>接下來，此paper也測試了不同的 w 對於訓練的成效： <a href="https://en.wikipedia.org/wiki/F1_score" rel="external nofollow noopener noreferrer" target="_blank">f1 score</a> 的影響，f1 score是precision跟recall的綜合分數，其中：</p><ul><li>precision 是所有 model 顯示為 true，而真正為 true 的比例</li><li>recall 是所有真正為 true 的資料，被 model 標示為 true 的比例</li></ul><p>f1 score 就是 precision 和 recall 的 harmonic mean。<a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers" rel="external nofollow noopener noreferrer" target="_blank">harmonic mean</a>同時也被用在電阻的並聯計算上，你可以想像電阻並聯時，假如任何一個電阻太小，電流就會傾向從那裡通過，造成等效電阻很小。同理，你可以想像有一顆電阻叫做precision，另一顆叫做recall，任何一方太小，都會導致f1 score 變得很小。於是 f1 score 就是同時可以兼具 recall 和 accuracy 的一個優化指標。</p><center><img src="/機器學習-總體經濟/w.png" title="漲跌的時間窗格與 f1 score 比較"></center><p>上圖中的兩條線分別是 positive 和 negative 的 f1 score。當 w 在 0 或是 50 時，f1 score 相對來說比較好。</p><p>以上就是分析 w、K、等參數怎麼設定比較好的一些分析，當我們得到這些參數，並且建構出預測漲跌的model後，就可以將model產生的結果拿來回測</p><h3 id="回測績效"><a href="#回測績效" class="headerlink" title="回測績效"></a>回測績效</h3><p>這邊總共用了三種方法來回測：</p><ol><li>假如預測會漲，就持續於整段回測週期持有股票</li><li>當預測會漲機率上升時，持有股票，不然則賣出</li><li>當預測會漲時，持有，反之則賣出</li></ol><p>以下是回測的結果：</p><center><img src="/機器學習-總體經濟/backtest.png" title="回測"></center><p>可以發現利用第三種方式，回測的績效比較好，這邊跟我自己做出來的結論是差不多的。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>今天學到的一些知識：</p><ol><li>用cross-correlation來分析features</li><li>利用SVM來測驗單個features是否有辦法預測漲跌，進而分析feature的好壞</li><li>使用移動窗格來找出最佳的f1_score</li></ol><p>這篇paper利用ML的方式，找出世界上重要的商品價格之間的關聯，並且也有使用SVM或是MART來預測NASDAQ指數的漲跌，個人覺得滿有趣的。經總就應該這樣作研究！</p><p>美中不足的是應該可以歸納出一些現象，輔助一般不會程式的投資人，這樣會更好！</p><p><a href="https://pdfs.semanticscholar.org/b68e/8d2f4d2c709bb5919b82effcb6a7bbd3db37.pdf" rel="external nofollow noopener noreferrer" target="_blank">論文網址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天&lt;a href=&quot;https://pdfs.semanticscholar.org/b68e/8d2f4d2c709bb5919b82effcb6a7bbd3db37.pdf&quot; rel=&quot;external nofollow noopener noreferrer&quot; ta
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>論文導讀：機器學習與基因演算法選股</title>
    <link href="https://www.finlab.tw/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E8%88%87%E5%9F%BA%E5%9B%A0%E6%BC%94%E7%AE%97%E6%B3%95%E9%81%B8%E8%82%A1/"/>
    <id>https://www.finlab.tw/機器學習與基因演算法選股/</id>
    <published>2018-11-27T06:41:15.000Z</published>
    <updated>2018-11-29T17:04:10.963Z</updated>
    
    <content type="html"><![CDATA[<p>feature selection 是機器學習中非常重要的一環，尤其是財經領域的程式交易部分，因為財經領域有各式各樣的指標，又有財報、技術指標，這些指標高達尚千種，要如何選擇features，才能更有效預測股價？</p><p>今天介紹一篇<a href="https://arxiv.org/pdf/1806.01743.pdf" rel="external nofollow noopener noreferrer" target="_blank">論文</a>，使用了基因演算法來幫忙選擇features，以下是更進一步的介紹：</p><center><img src="/機器學習與基因演算法選股/thumbnail.jpg" title="基因演算法"></center><p>對於machine learning的程式交易演算法來說，<br>首先要有features，features可以想像成是指標，每一支股票都會有其features。<br>另外還有labels，也就是我們希望能夠預測的數值，例如股價漲跌的幅度，或是sharp ratio。</p><p>只要有了features跟labels，剩下的就簡單了，只要把這些features跟labels都輸入到一個黑盒子裡面，讓它學習，學成之後，只需要每次給它新的features，它就會預判label是多少。這個黑盒子通常稱為model，model有很多種類，最常見的就是deep neural network或是 random forest ，這些我們待會會簡單的介紹。</p><p>本篇論文在選擇features的階段，使用了基因演算法，由於財報、技術指標的數字有上千種，該如何選擇呢？第一步驟就是就全部都選擇吧！反正基因演算法會找出有用的features並且刪除無用的，至於基因演算法是如何做到的？它是模仿達爾文物競天擇的方式來找出有用的features：</p><h3 id="第一步：決定染色體"><a href="#第一步：決定染色體" class="headerlink" title="第一步：決定染色體"></a>第一步：決定染色體</h3><p>以數學的方式描述，染色體是一條一維向量，其長度為所有features的長度，其數值為0或1，0代表不選入該feature，1代表選入該feature。</p><p>一開始會隨機製作出100條染色體，想必效果就是很隨機的，不是很好。<br>然而生物是會進化的，適者生存、不適者淘汰，要怎麼定義要淘汰的染色體呢？</p><center><img src="/機器學習與基因演算法選股/crossover_bits.png" title="兩條染色體互相結合"></center><h3 id="第二步：決定染色體的成績"><a href="#第二步：決定染色體的成績" class="headerlink" title="第二步：決定染色體的成績"></a>第二步：決定染色體的成績</h3><p>每一種染色體都代表一組features的選擇，單一染色體拿出來，用染色體所選入的features進行機器學習，最後評估機器學習的成果。在論文中，是使用<a href="https://medium.com/greyatom/lets-learn-about-auc-roc-curve-4a94b4d88152" rel="external nofollow noopener noreferrer" target="_blank">AUC</a>來當作每個染色體的成績。</p><p>當然這時就可以進行適者生存、不適者淘汰的步驟，選出100個成績比較好的染色體，成績越好的染色體越有機會被選出來，但是也有可能成績很好但懷才不遇被篩選掉，這邊此文並沒有很明確的說明機制是什麼，實作上也有很多種方法，最簡單就是直接選成績最好的100個染色體。</p><center><img src="/機器學習與基因演算法選股/selection.png" title="模擬物競天擇"></center><p>這個目的在於，基因演算法的最後，我們希望選出一條染色體，其AUC算出來是最高的，代表它能夠很有效的分別出會漲的股票跟會跌的股票。</p><h3 id="第三步：交叉遺傳"><a href="#第三步：交叉遺傳" class="headerlink" title="第三步：交叉遺傳"></a>第三步：交叉遺傳</h3><p>我們會由現有的染色體，藉由排列組合，產生更多的染色體，具體的做法是：產生新的20條染色體，每條染色體皆由某兩條現有染色體的片段所組成，例如染色體的上半部和下半部是由不同染色體所提供的。</p><center><img src="/機器學習與基因演算法選股/crossover.jpg" title="兩條染色體互相結合"></center><h3 id="第四步：變異"><a href="#第四步：變異" class="headerlink" title="第四步：變異"></a>第四步：變異</h3><p>這個步驟中，這120條染色體會稍微的被隨機修改，每條染色體有10％的機率，其當中的一個bit會被反轉（由0變成1，或是1變成0）</p><center><img src="/機器學習與基因演算法選股/mutation.png" title="變異"></center><p>上圖是一個三個bit變異的例子，有很多種的變異方式，本文中一次只更動一個bit而已。</p><h3 id="回到第二步，開始生物演化的循環"><a href="#回到第二步，開始生物演化的循環" class="headerlink" title="回到第二步，開始生物演化的循環"></a>回到第二步，開始生物演化的循環</h3><p>每經過一次2、3、4步驟，就像是完成了一個世代，隨著是帶的變遷，平均來說，AUC的成績應該會越來越好，直到AUC的成績不再進步，就可以停止演化的過程。而其成果就是步驟二中，選出擁有最高的AUC的染色體，代表這些被選到的features組合在一起，預測能力是最強的！</p><center><img src="/機器學習與基因演算法選股/evolution.png" title="利用演算法模擬演化的過程，進而找到最佳解"></center><h2 id="機器學習"><a href="#機器學習" class="headerlink" title="機器學習"></a>機器學習</h2><p>我們剛剛有說的，機器學習的model就像是黑盒子一樣，文中主要使用兩種model：deep neural network和random forest，都是非常常見的model，兩種model都有其優缺點，不一定哪個比較好。所以本文也提出了stacking的方式，將這兩種黑盒子的結果取平均，得出最後的答案，結果發現比單獨使用這兩種model更好。</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>我個人是滿好奇features沒有經過normalize就跑DNN不會有問題嗎？滿奇怪的，感覺DNN應該要額外再preprocessing一下，但是文中並沒有提到，就當作作者忘記說明好了。</p><p>我以前的做法是自己憑經驗找有效的features並且放進去測試，這篇文章使用了基因演算法來幫助大家篩選features，進行程式交易，大量的降低了人工feature engineering的時間，當然電腦也是要算很久，雖然我沒試過，但以普通單機電腦來說，估計要好幾天才能跑出最佳解。個人認為這篇論文實做起來是有效的。</p><p><a href="https://arxiv.org/pdf/1806.01743.pdf" rel="external nofollow noopener noreferrer" target="_blank">論文網址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;feature selection 是機器學習中非常重要的一環，尤其是財經領域的程式交易部分，因為財經領域有各式各樣的指標，又有財報、技術指標，這些指標高達尚千種，要如何選擇features，才能更有效預測股價？&lt;/p&gt;
&lt;p&gt;今天介紹一篇&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="AI看股票" scheme="https://www.finlab.tw/categories/AI%E7%9C%8B%E8%82%A1%E7%A5%A8/"/>
    
    
      <category term="機器學習" scheme="https://www.finlab.tw/tags/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"/>
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="量化投資" scheme="https://www.finlab.tw/tags/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B3%87/"/>
    
  </entry>
  
  <entry>
    <title>加速度指標：歷史年報酬20％的策略</title>
    <link href="https://www.finlab.tw/%E5%8A%A0%E9%80%9F%E5%BA%A6%E6%8C%87%E6%A8%99-%E5%8A%A0%E9%80%9F%E4%BD%A0%E7%9A%84%E7%8D%B2%E5%88%A9/"/>
    <id>https://www.finlab.tw/加速度指標-加速你的獲利/</id>
    <published>2018-11-24T20:11:28.000Z</published>
    <updated>2019-03-08T14:39:58.752Z</updated>
    
    <content type="html"><![CDATA[<p>之前分享加速度指標，讓大家找出股價正在加速向上的股票，然而並沒有說明怎麼搭配，本篇文章就是在提供大家一個例子，我發現這個指標可以用在非常多種不同的程式交易策略上，績效很不錯，但是有訣竅。</p><h3 id="加速度指標回顧"><a href="#加速度指標回顧" class="headerlink" title="加速度指標回顧"></a>加速度指標回顧</h3><p>加速度指標，其實就是看均線的曲率是正的還是負的，但是由於股價的雜訊太大了，與其用微分的，我們提供一個比較間單的方式，來判斷曲率的正負：</p><p>(n天前 + 當天)/2 &gt; n/2天前 的k天均線</p><p>我們就說它正在加速，是很不錯的持有標的，至於背後的原理可以參考<a href="/簡易的外資-基本面策略/">之前的文章</a>！但是加速度指標還是有其弱點，必須要搭配其他指標，才能發揮作用</p><h3 id="加速度指標的癥結1：初始速度"><a href="#加速度指標的癥結1：初始速度" class="headerlink" title="加速度指標的癥結1：初始速度"></a>加速度指標的癥結1：初始速度</h3><p>加速度最大的癥結就在於，你不知道其速度！例如現在有兩個人賽跑，其中一個人加速度是正的，另一個人是負的，究竟誰會先抵達終點？</p><p>答案是不知道</p><p>因為你不知道起始速度是多少，假如有一個人根本逆著終點跑，就算他加速多快都沒有用！<br>就像有一支股票，只要止跌，其曲率就會看起來是正的，但是止跌的股票還會有一段震蕩，甚至有續跌的可能，所以買剛止跌的時候就買是沒有意義的，我們應該是要買剛起漲的股票才對～</p><p>下圖就是曲率正負和股價之間的分類，曲率為正時，股價有兩種可能：止跌、起漲。曲率為負時，股價也有兩種可能：止漲、起跌。</p><center><img src="/加速度指標-加速你的獲利/cases.jpg" title="正負曲率所對應到的股價"></center><p>當我們使用曲率為正的條件時，就會發現我們選到「止跌」或「起漲」股，然而我們真正是想選取「起漲」股，假如我們選了起漲股，那賣出時，曲率為負，自然就是止漲，而不會選到起跌股。</p><h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>所以我們加上一個股價的向上指標即可，這邊你可以使用KD值的K&gt;D（參數：240、120、120），來找出股價向上的股票，這樣加速度指標才有意義喔！</p><p>當然有很多種趨勢型指標都可以拿來用用看～我相信一定會有更好的選項，這邊只是舉例。</p><h3 id="加速度指標的癥結2：採樣點太少"><a href="#加速度指標的癥結2：採樣點太少" class="headerlink" title="加速度指標的癥結2：採樣點太少"></a>加速度指標的癥結2：採樣點太少</h3><p>基本上加速度指標就是三個點比大小，採樣的點非常少，就像電影只看開頭和結尾，想要把中間劇情都猜出來，是不太容易的。</p><p>下圖左方的例子中，我們只用了三個點來衡量曲率是正的還是負的（或是你可以想像是凹的還是凸的），可以發現就算曲率是正的，也有可能並不是我們想要的股價曲線。其中，紅色的股價是我們比較希望的，而不是綠色的。</p><h3 id="解決方法：多增加條件"><a href="#解決方法：多增加條件" class="headerlink" title="解決方法：多增加條件"></a>解決方法：多增加條件</h3><p>所以我們可以測試多個點，右圖我們用「兩組」三個點來觀察曲率（藍色跟黃色）可以發現，右上方得圖，不論用藍色的三個點或是黃色的三個點，曲率都是正的，而右下角的圖中，雖然用藍色的點看，曲率是正的，但是用黃色的點看的話，曲率是負的，於是就可以將這類型的股價給排除。</p><center><img src="/加速度指標-加速你的獲利/samples.jpg" title="一個曲率條件跟兩個曲率條件"></center><p>加速度指標要決定一個變數：n，是一個時間長度。我們可以列出多個n值不同加速度指標，這些加速度指標都符合時，我們再進行買入的動作。</p><p>我們讓n設定為50、20、15、10，一次增加四個加速度指標，來監控60天均線的曲率<br>賣出條件是n=30這個指標不符合條件時，於隔天剃除</p><h3 id="加速度指標的癥結3：沒有考慮公司營運狀況"><a href="#加速度指標的癥結3：沒有考慮公司營運狀況" class="headerlink" title="加速度指標的癥結3：沒有考慮公司營運狀況"></a>加速度指標的癥結3：沒有考慮公司營運狀況</h3><p>加速度指標為技術指標，並沒有考慮財報面，只要稍微判斷一下財報的狀況，就可以選出很不錯的股票～</p><h3 id="解決辦法"><a href="#解決辦法" class="headerlink" title="解決辦法"></a>解決辦法</h3><p>由於財報並不是這個策略的主角，我只用 ROE &gt; 3 這樣的條件就很足夠了</p><h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>我們敘述了加速度指標的不足，並且有根據的介紹怎麼樣新增條件，來完善我們的策略，以下就是這個策略的績效：</p><center><img src="/加速度指標-加速你的獲利/eq.png" title="獲利的績效"></center><p>藍色的為不添加手續費，而紅色的則是添加了手續費～效果滿不錯的！</p><p>這些參數我都沒有做任何優化，當然這些參數的選擇上還是得靠經驗，然而假如對於這些數字指標比較熟悉，大概就可以抓出有效的區間，進而選出好的標的。經過簡單的優化，甚至是增刪條件，都可以讓績效再提升。</p><p>下圖可以看到，最大下跌幅度在金融海嘯的時候莫名的高，必須要注意一下～～</p><center><img src="/加速度指標-加速你的獲利/mdd.png" title="最大下跌幅度"></center><p>對了，補充一下，我們的新平台悄悄上線，目前正在測試中，此策略的選股清單可以免費觀看：<a href="https://ai.finlab.tw/strategy/%E5%8A%A0%E9%80%9F%E5%BA%A6%E9%A0%86%E5%8B%A2%E7%AD%96%E7%95%A5" rel="external nofollow noopener noreferrer" target="_blank">加速度策略</a></p><p>這邊只是給大家一個雛形，可以將加速度指標用在股價，甚至是其他的財務數據上（月營收？），感覺都會滿有趣的！</p><p>假如你想用Python來實做，可以參考下一篇：<a href="/加速度指標實做/">實做加速度指標</a>！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前分享加速度指標，讓大家找出股價正在加速向上的股票，然而並沒有說明怎麼搭配，本篇文章就是在提供大家一個例子，我發現這個指標可以用在非常多種不同的程式交易策略上，績效很不錯，但是有訣竅。&lt;/p&gt;
&lt;h3 id=&quot;加速度指標回顧&quot;&gt;&lt;a href=&quot;#加速度指標回顧&quot; cla
      
    
    </summary>
    
      <category term="選股策略" scheme="https://www.finlab.tw/categories/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="簡易策略" scheme="https://www.finlab.tw/tags/%E7%B0%A1%E6%98%93%E7%AD%96%E7%95%A5/"/>
    
      <category term="選股策略" scheme="https://www.finlab.tw/tags/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
      <category term="歷史回測" scheme="https://www.finlab.tw/tags/%E6%AD%B7%E5%8F%B2%E5%9B%9E%E6%B8%AC/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>用KD值選股：還需搭配這三種指標</title>
    <link href="https://www.finlab.tw/%E7%94%A8KD%E5%80%BC%E9%81%B8%E8%82%A1%EF%BC%9A%E9%82%84%E9%9C%80%E6%90%AD%E9%85%8D%E9%80%99%E4%B8%89%E7%A8%AE%E6%8C%87%E6%A8%99/"/>
    <id>https://www.finlab.tw/用KD值選股：還需搭配這三種指標/</id>
    <published>2018-11-21T16:13:35.000Z</published>
    <updated>2018-11-29T17:13:37.627Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章將分享一個程式交易策略，以KD值為主，並且搭配其他的指標。<br>有很多人投資是看KD值的，但KD值的看法五花八門，究竟哪一種比較好用？<br>參數這麼多，究竟怎麼調績效比較好？<br>這篇文章示範一個中長期的程式交易策略，並講解製作策略的思路。</p><a id="more"></a><p>寫策略並模擬回測績效是非常重要的，通過回測，就能一眼看出來你的策略有沒有效。有人說歷史不等於未來，我覺得更正確的說，應該是「歷史不完全等於未來」，每年都有很多不同的黑天鵝，不同的國際政治變化，政黨輪替，然而假如你可以找到一個策略，不論環境如何變化，但是績效一直有穩定的成長，就代表你有可能找到了「歷史與未來會相同的某種選股邏輯」！</p><h3 id="KD值"><a href="#KD值" class="headerlink" title="KD值"></a>KD值</h3><p>今天我們就來試驗一下KD值程式交易選股，<br>首先，我傾向於把指標的參數拉長，原因是這樣比較容易抓的到股價的規律（以日K來說）。<br>不過我個人的研究發現趨勢指標型態不一樣，選出來的股票也會不一樣，<br>絕對不是只要股價會漲就好，而是要符合某些特定的數學條件。</p><p>這邊我選擇使用RSV 50, K 20, D 20，當作是參數（台股通常是9、3、3）。<br>當K大於D的時候買入，反之賣出，每天選股並重新平衡資產，可以得到以下的績效：</p><center><img src="/用KD值選股：還需搭配這三種指標/eq1.png" title="績效"></center><br><center><img src="/用KD值選股：還需搭配這三種指標/ns1.png" title="股票檔數"></center><p>紅色的是有考慮手續費，而藍色的則無。</p><p>然而這樣的選法是有一些弊端的！（尤其是手續費很高昂，股票換手率太高）<br>所以接下來我們就想辦法來解決，順便提高一下程式交易的績效～</p><h3 id="長期趨勢漲，可能會買在高點！"><a href="#長期趨勢漲，可能會買在高點！" class="headerlink" title="長期趨勢漲，可能會買在高點！"></a>長期趨勢漲，可能會買在高點！</h3><p>當K &gt; D時，股價會衝的很高，但是這時候買入就會買在高點了！<br>所以我們在使用長線KD值時，可以增加一個條件來確保不會買在高點：</p><p>當天股價 &lt; 10日平均</p><p>除了股價不能太高，同時股價也不能太低！</p><h3 id="股價必須高於年線"><a href="#股價必須高於年線" class="headerlink" title="股價必須高於年線"></a>股價必須高於年線</h3><p>我們在此參數下選出來的股票，假如股價沒有過年線的話，很容易漲到年線附近時，就被彈了回去，所以乾脆我們選股的時候，就直接選高於年線的，就不會有這個問題了XD</p><h3 id="增加一些常用的財務指標"><a href="#增加一些常用的財務指標" class="headerlink" title="增加一些常用的財務指標"></a>增加一些常用的財務指標</h3><p>程式交易除了用技術指標外，我們也可以增加一些財務指標，例如ROE：<br>ROE近1季大於ROE近4季平均</p><p>當然也有很多別的選項，我這邊就選一個好用的入門款XD，</p><h3 id="三種條件依序加上後的結果"><a href="#三種條件依序加上後的結果" class="headerlink" title="三種條件依序加上後的結果"></a>三種條件依序加上後的結果</h3><p>可以發現，從下到上依序就是：</p><ol><li>使用KD值</li><li>除了上述以外，額外增加：股價短線別太高</li><li>除了上述以外，額外增加：股價長線別太低</li><li>除了上述以外，額外增加：財務數據</li></ol><center><img src="/用KD值選股：還需搭配這三種指標/eqall.png" title="條件選股比較"></center><p>不過以上是沒有增加手續費的，因為我的回測系統每天都會重新權益平衡，所以有非常多不必要的摩擦成本，此時手續費折扣就非常的重要了！</p><p>最後我新增了一些不太重要的條件（為了減少股票檔數），整理成下圖，紅色為有手續費，藍色沒有手續費，只能說以人工調配持股應該會有更好的成果～有興趣可以研究看看！</p><center><img src="/用KD值選股：還需搭配這三種指標/eqf.png" title="績效"></center><br><center><img src="/用KD值選股：還需搭配這三種指標/nsf.png" title="股票檔數"></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;這篇文章將分享一個程式交易策略，以KD值為主，並且搭配其他的指標。&lt;br&gt;有很多人投資是看KD值的，但KD值的看法五花八門，究竟哪一種比較好用？&lt;br&gt;參數這麼多，究竟怎麼調績效比較好？&lt;br&gt;這篇文章示範一個中長期的程式交易策略，並講解製作策略的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="選股策略" scheme="https://www.finlab.tw/categories/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
    
      <category term="選股策略" scheme="https://www.finlab.tw/tags/%E9%81%B8%E8%82%A1%E7%AD%96%E7%95%A5/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="KD" scheme="https://www.finlab.tw/tags/KD/"/>
    
      <category term="技術指標" scheme="https://www.finlab.tw/tags/%E6%8A%80%E8%A1%93%E6%8C%87%E6%A8%99/"/>
    
  </entry>
  
  <entry>
    <title>Python：如何獲得上市上櫃股票清單</title>
    <link href="https://www.finlab.tw/Python%EF%BC%9A%E5%A6%82%E4%BD%95%E7%8D%B2%E5%BE%97%E4%B8%8A%E5%B8%82%E4%B8%8A%E6%AB%83%E8%82%A1%E7%A5%A8%E6%B8%85%E5%96%AE/"/>
    <id>https://www.finlab.tw/Python：如何獲得上市上櫃股票清單/</id>
    <published>2018-11-19T15:55:04.000Z</published>
    <updated>2018-11-29T17:08:14.711Z</updated>
    
    <content type="html"><![CDATA[<p>接下來為期幾天，將為大家打下python更深刻的基礎，適合剛學python，但是對pandas不太熟的讀者，這次我們就來把所有的股票代號給爬下來，並整理一番喔！</p><p>Python真的很厲害～可以用少少的語法達到非常多的功能<br>我覺得python搭配excel是沒有必要的，直接使用python替代excel才是最佳的方式！</p><center><img src="/Python：如何獲得上市上櫃股票清單/6.png" title="python基礎教學"></center><p>這禮拜終於比較悠閒一點，開始寫blog了，目前主要還是繼續培養大家的python實力為主，因為有一些同學說明課程有些地方跳的比較快，其實可以參考一些網路上免費的python課程來補齊，不過此blog也會隨時補充一些實用的功能，或是簡單的 python 常用的package和語法，幫助大家熟練 python。</p><p>今天要做的就是取得上市櫃股票代號與分類，首先，我們想要爬的網頁是：<br><a href="http://isin.twse.com.tw/isin/C_public.jsp?strMode=2" rel="external nofollow noopener noreferrer" target="_blank">http://isin.twse.com.tw/isin/C_public.jsp?strMode=2</a></p><p>其中<code>strMode=2</code>就是上市，而<code>strMode=4</code>就是上櫃，接下來我們就來將此網頁下載下來吧！</p><h3 id="爬取網頁"><a href="#爬取網頁" class="headerlink" title="爬取網頁"></a>爬取網頁</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">"http://isin.twse.com.tw/isin/C_public.jsp?strMode=2"</span>)</span><br></pre></td></tr></table></figure><p>其中，我們使用了常用的 package 叫做 requests，可以模擬網頁瀏覽器，其中 <code>requests.get</code> 就是模擬我們連到該網頁，下載網頁的原始碼～</p><center><img src="/Python：如何獲得上市上櫃股票清單/1.png" title="爬取網頁"></center><h3 id="將網頁轉成-DataFrame"><a href="#將網頁轉成-DataFrame" class="headerlink" title="將網頁轉成 DataFrame"></a>將網頁轉成 DataFrame</h3><p>我們用了上述的程式碼，就可以獲得該網頁的原始碼，瀏覽器就是用這些原始碼渲染成網頁讓您操作的，我們可以從網頁原始碼中萃取出表格，產生 DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_html(res.text)[<span class="number">0</span>]</span><br><span class="line">df</span><br></pre></td></tr></table></figure><p>第一行：<code>pd</code> 就是我們萃取原始碼的package，全名叫做 <code>pandas</code> ，你可以想像 <code>pandas</code> 就是 python 界的 <code>excel</code> 軟體，可以操作各式各樣的表格，進行運算。</p><p>第三行：我們可以利用 <code>pd.read_html</code> 將我們剛剛爬取到的網頁原始碼 <code>res.text</code> 中的表格給萃取出來，而其中 <code>[0]</code> 是指說，萃取出來的可能有很多張表格，我們只需要第一張表格即可～</p><center><img src="/Python：如何獲得上市上櫃股票清單/2.png" title="將網頁轉成DataFrame"></center><h3 id="整理資料-1-整理column名稱"><a href="#整理資料-1-整理column名稱" class="headerlink" title="整理資料 1 整理column名稱"></a>整理資料 1 整理column名稱</h3><p>可以看到上圖，目前column名稱只是1、2、3、4，一些數字而已，但我們希望它們是有意義的文字，而我們又可以發現，其中第一行row，就是我們所需要的，所以，我們可以將第一行變成columns的名稱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定column名稱</span></span><br><span class="line">df.columns = df.iloc[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 刪除第一行</span></span><br><span class="line">df = df.iloc[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><center><img src="/Python：如何獲得上市上櫃股票清單/3.png" title="整理column名稱"></center><h3 id="整理資料-2-刪除冗餘行列"><a href="#整理資料-2-刪除冗餘行列" class="headerlink" title="整理資料 2 刪除冗餘行列"></a>整理資料 2 刪除冗餘行列</h3><p>接下來我們發現整理好column名稱後，還是有一些row很明顯是多餘的，我們必須要把它們刪除，刪除的方式，最簡單就是使用 <code>dropna</code>，並且設定當 <code>row</code> 或是 <code>column</code> 的 <code>NaN</code> 數量大於某個數字（例如3）時，我們就將該 <code>column</code> 或 <code>row</code> 移除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先移除row，再移除column，超過三個NaN則移除</span></span><br><span class="line">df = df.dropna(thresh=<span class="number">3</span>, axis=<span class="number">0</span>).dropna(thresh=<span class="number">3</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><center><img src="/Python：如何獲得上市上櫃股票清單/4.png" title="刪除多餘的行列"></center><h3 id="設定index"><a href="#設定index" class="headerlink" title="設定index"></a>設定index</h3><p>我們可以看到index目前也是數字，我們希望它是股票代號，則可以使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.set_index(<span class="string">'有價證券代號及名稱'</span>)</span><br></pre></td></tr></table></figure><br>即可！</p><center><img src="/Python：如何獲得上市上櫃股票清單/5.png" title="最後的成果"></center><p>由今天的練習，我們學到了使用 <code>requests</code> 來模擬瀏覽器，用 <code>pandas</code> 解析出網頁中的 table，並且利用 <code>pandas</code> 中的功能，將 table 作整理！</p><p>博士班口試結束了，接下來我會盡力開始維持blog正常出貨！也希望能提供更多的選股、程式上的教學！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下來為期幾天，將為大家打下python更深刻的基礎，適合剛學python，但是對pandas不太熟的讀者，這次我們就來把所有的股票代號給爬下來，並整理一番喔！&lt;/p&gt;
&lt;p&gt;Python真的很厲害～可以用少少的語法達到非常多的功能&lt;br&gt;我覺得python搭配excel是
      
    
    </summary>
    
      <category term="python財經" scheme="https://www.finlab.tw/categories/python%E8%B2%A1%E7%B6%93/"/>
    
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="爬蟲" scheme="https://www.finlab.tw/tags/%E7%88%AC%E8%9F%B2/"/>
    
      <category term="入門教學" scheme="https://www.finlab.tw/tags/%E5%85%A5%E9%96%80%E6%95%99%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>超簡單用Python預測股價</title>
    <link href="https://www.finlab.tw/%E8%B6%85%E7%B0%A1%E5%96%AE-Machine-Learning-%E9%A0%90%E6%B8%AC%E8%82%A1%E5%83%B9/"/>
    <id>https://www.finlab.tw/超簡單-Machine-Learning-預測股價/</id>
    <published>2018-08-27T17:55:29.000Z</published>
    <updated>2018-11-29T17:05:14.311Z</updated>
    
    <content type="html"><![CDATA[<p>多虧了python，用最先進的統計模型來預測股價，程式交易超簡單！<br>不用安裝程式，今天我們雲端寫code，適合完完全全的初學者！<br>非常多非常多的人都用 python 在開發程式，<br>因此，有很多高深數學軟體，都會有很多民間高手來實做，<br>而我們只要會用就好了！學python從這篇開始！<br><a id="more"></a></p><center><img src="/超簡單-Machine-Learning-預測股價/j4.png" title="短中長線預測"></center><p>我們還是來稍微科普一下相關的程式交易知識好了</p><h3 id="什麼是model（模型）"><a href="#什麼是model（模型）" class="headerlink" title="什麼是model（模型）"></a>什麼是model（模型）</h3><p>模型就是一種能夠預測真實資料的數學公式，<br>通常會是一個function，例如 f 好了，<br>假如我們有一條時間序列 f(t) = at + b<br>只要知道了變數 a 跟 b，就可以計算出 t 每一刻的 f(t) 是多少</p><p>要怎麼知道 a 跟 b 是多少？<br>只要看其中兩個歷史時刻的位置即可：例如我們知道 f(1) = 1 且 f(2) = 2<br>則我們可以推算出 a = 1 且 b = 0，<br>並且預知 f(3) = 3 、 f(4) = 4 、 f(5) = 5 …</p><p>股價模型也是一樣，但是這個模型會比較複雜，不會只有 a、b 而已<br>不過規則是一樣的，我們要用歷史股價去計算類似 a、b 的變數，通常稱之為 fitting<br>找到 a、b 後就能夠用模型來預測股價了！</p><h3 id="用什麼模型預測股價呢？"><a href="#用什麼模型預測股價呢？" class="headerlink" title="用什麼模型預測股價呢？"></a>用什麼模型預測股價呢？</h3><p>Facebook 最近推出了一個新型的時間序列預測模型Prophet，中文叫作預言家，<br>預言家可以預測一些週期性的時間序列<br>例如下圖，一個FB每天PO文的數量圖，隨時間關係圖：</p><center><img src="/超簡單-Machine-Learning-預測股價/pp1.png" title="每天PO文的數量 DataFrame"></center><p>截圖自<a href="https://peerj.com/preprints/3190.pdf" rel="external nofollow noopener noreferrer" target="_blank">fb論文</a></p><p>圖中，每個時間都只會對應到一個點，就是每天的PO文數量<br>我們可以觀察到一些現象：</p><h3 id="以每週來檢視"><a href="#以每週來檢視" class="headerlink" title="以每週來檢視"></a>以每週來檢視</h3><p>上圖中，顏色的不同代表每週的變化量，禮拜六看起來明顯就比較少人用FB，<br>（週末都跑去玩了？XD）</p><h3 id="以每年來檢視"><a href="#以每年來檢視" class="headerlink" title="以每年來檢視"></a>以每年來檢視</h3><p>我們也可以發現，以年度來說，暑假時PO文數會下降<br>（大家都去放暑假了？）</p><p>每個週期下都有各自的規律，傳統的模型能夠成功預測嗎？</p><h3 id="傳統模型的限制"><a href="#傳統模型的限制" class="headerlink" title="傳統模型的限制"></a>傳統模型的限制</h3><p>其實已經有很多模型了，但為什麼FB還要推出一個新的呢？<br>原因是，以前的模型並沒有辦法多週期性的預測 f(t) ：</p><center><img src="/超簡單-Machine-Learning-預測股價/pp2.png" title="傳統模型預測的結果 DataFrame"></center><p>這張圖的每個row是不同的模型<br>圖中每條「實線」就是預測模型的結果，<br>可以看出以往的模型，預測出來結果並不是很準</p><h3 id="預言家模型"><a href="#預言家模型" class="headerlink" title="預言家模型"></a>預言家模型</h3><p>下圖中，可以發現預言家模型比上述的模型預測的更準確</p><center><img src="/超簡單-Machine-Learning-預測股價/pp3.png" title="預言家模型預測的結果 DataFrame"></center><p>預言家模型最厲害的地方，<br>就是用多條 Fourier Series，去擬合（fitting）時間序列<br>在這邊就不把可怕的公式放上來了，<br>有興趣可以參考 <a href="https://peerj.com/preprints/3190.pdf" rel="external nofollow noopener noreferrer" target="_blank">fb論文</a><br>可以將週期調整至「每年」「每季」「每週」！<br>模型簡單可以寫成這樣：</p><p>f(t) = year(t) + season(t) + week(t) + trend(t)</p><p>甚至在fitting完（找到a、b等參數後）可以將 f(t) 的成分拆解出來看：</p><center><img src="/超簡單-Machine-Learning-預測股價/pp5.png" title="不同週期下的函數 DataFrame"></center><p>而最後的 f(t) 就是這些曲線的疊加，<br>由上圖第三張，我們可以額外發現，聖誕節的時候，使用FB的人數下降非常快<br>外國的聖誕節，就是與家人團聚的時光，（像是我們的農曆新年）<br>所以不太會用手機的緣故</p><p>這篇論文大意就講到這裡，<br>詳情可以參考：<a href="https://peerj.com/preprints/3190.pdf" rel="external nofollow noopener noreferrer" target="_blank">此論文</a></p><h3 id="用預言家預測股票"><a href="#用預言家預測股票" class="headerlink" title="用預言家預測股票"></a>用預言家預測股票</h3><p>看完了學術的部分，接下來我們就實際的來使用預言家模型預測股價吧！<br>要預測的精準，我們要找有週期性的股票來分析，<br>這邊我就隨性的拿台積電當作是標的來預測囉～</p><h3 id="超簡單環境設定"><a href="#超簡單環境設定" class="headerlink" title="超簡單環境設定"></a>超簡單環境設定</h3><p>安裝python、安裝jupyter？<br>不用，google提供了強大的雲端notebook，讓我們可以直接玩程式：<br><a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">https://colab.research.google.com/</a><br>打開連結，開啟新的notebook，在雲端寫程式！<br>當然你有python也可以開自己的，快的多</p><p>這次為了方便大家學習，我已經將環境建設好了！<br>在任意cell輸入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git clone https://github.com/koreal6803/Stocker.git</span><br><span class="line">!pip install -r Stocker/requirements.txt</span><br></pre></td></tr></table></figure><br>即可完成！<br>需要一段安裝時間，使用google colab的話，可以去休息一下，喝個水再回來XD</p><center><img src="/超簡單-Machine-Learning-預測股價/j0.png" title="初始設定"></center><p>上述代碼中，每行開頭的驚嘆號，可以讓你把jupyter 當作 terminal 在用，<br>（不過假如windows用戶沒有git可能就無法…點上面google 線上程式連結）</p><h3 id="去除煩人的-warrning"><a href="#去除煩人的-warrning" class="headerlink" title="去除煩人的 warrning"></a>去除煩人的 warrning</h3><p>接下來，我們先來刪除惱人的warrning，最近pandas越來越煩<br>一堆warrning…看了心煩直接刪除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="comment">### 去除煩人的 warrning</span></span><br><span class="line">warnings.filterwarnings(<span class="string">'ignore'</span>)</span><br></pre></td></tr></table></figure><h3 id="讀入台積電股價"><a href="#讀入台積電股價" class="headerlink" title="讀入台積電股價"></a>讀入台積電股價</h3><p>接下來就讀入附帶的台積點股價：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">### 讀入series</span></span><br><span class="line">df = pd.read_csv(<span class="string">'Stocker/price.csv'</span>, index_col=<span class="string">'date'</span>, parse_dates=[<span class="string">'date'</span>])</span><br><span class="line">price = df.squeeze()</span><br><span class="line">price.head()</span><br></pre></td></tr></table></figure><center><img src="/超簡單-Machine-Learning-預測股價/j1.png" title="讀取台積點收盤價"></center><p>其中的squeeze就是將dataframe變成series的function，<br>你可以用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(df)</span><br><span class="line">print(df.squeeze)</span><br></pre></td></tr></table></figure><br>來查看其中差別</p><h3 id="創建Stocker"><a href="#創建Stocker" class="headerlink" title="創建Stocker"></a>創建Stocker</h3><p>這個Stocker並不是我寫的package，<br>而是利用<a href="https://github.com/WillKoehrsen/Data-Analysis/tree/master/stocker" rel="external nofollow noopener noreferrer" target="_blank">國外別人寫好的</a><br>，再額外修改成更方便的版本</p><p>用法很簡單，把股價的series丟進去就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Stocker.stocker <span class="keyword">import</span> Stocker</span><br><span class="line">tsmc = Stocker(price)</span><br></pre></td></tr></table></figure><h3 id="預測中期走勢"><a href="#預測中期走勢" class="headerlink" title="預測中期走勢"></a>預測中期走勢</h3><p>接下來我們就可以用它來預測中期走勢，只需要一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model, model_data = tsmc.create_prophet_model(days=<span class="number">90</span>)</span><br></pre></td></tr></table></figure><center><img src="/超簡單-Machine-Learning-預測股價/j2.png" title="讀取台積點收盤價"></center><p>其中綠色的就是預測出來的股價，而淺綠色區域就是信賴區間，股價大約就會落於此區間內，<br>程式中的信賴區間為80％，也代表了，每五天就約有一天的股價會落於信賴區間之外，<br>可以看到預測時間越久（沒實際股價的地方），不確定性越大，所以綠色的區間也就稍微變大<br>可以用來當作布林區間的感覺</p><h3 id="這樣預測準確嗎？"><a href="#這樣預測準確嗎？" class="headerlink" title="這樣預測準確嗎？"></a>這樣預測準確嗎？</h3><p>不確定，所以我們可以把時間還原到一年前，來看看假如當時預測的結果，跟至今是不是有差別，<br>我們不讓Stocker使用近一年的股價來fitting，出來的曲線跟實際的股價做比較：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsmc.evaluate_prediction()</span><br></pre></td></tr></table></figure><center><img src="/超簡單-Machine-Learning-預測股價/j3.png" title="預測準確度檢查"></center><p>上圖中，紅色虛線就是開始預測的當下，紅色線以後的時間都是預言家預測的結果<br>而藍色則為預測的真實股價，黃色則是信賴區間</p><h3 id="不準怎麼辦？"><a href="#不準怎麼辦？" class="headerlink" title="不準怎麼辦？"></a>不準怎麼辦？</h3><p>沒關係，我們可以調整短中長期的參數，讓它預測短中長期股價：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsmc.changepoint_prior_analysis(changepoint_priors=[<span class="number">0.001</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.2</span>])</span><br></pre></td></tr></table></figure><br>下圖中，可以看到藍色的線比較偏趨勢，不隨當下股價起舞，算是長期的趨勢預測<br>而黃色則是非常貼近股價，算是短期的預測<br>使用者可以自行調整參數，來決定短中長線的應用</p><center><img src="/超簡單-Machine-Learning-預測股價/j4.png" title="短中長線預測"></center><h3 id="拿來預測股價了！"><a href="#拿來預測股價了！" class="headerlink" title="拿來預測股價了！"></a>拿來預測股價了！</h3><p>我們藉由上述的參數枚舉，可以知道哪一個參數（<code>changepoint_prior</code>）是最好的<br>我們可以藉由執行<code>predict_future</code> 來預測股價囉！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsmc.predict_future(days=100)</span><br></pre></td></tr></table></figure></p><center><img src="/超簡單-Machine-Learning-預測股價/j5.png" title="讀取台積點收盤價"></center><p>藉由Stocker，我們可以很輕易的預測股價，<br>至於其準確性，還有待各位看官們回測看看囉！</p><p>有上左方課程的同學，可以很輕易的使用Stocker來檢驗歷史報酬率是多少！<br>可以試著找到最佳的參數，並盡量選擇有週期性的股票～<br>期待你們的成果！</p><p>此程式的一些連結：<br><a href="https://github.com/koreal6803/Stocker" rel="external nofollow noopener noreferrer" target="_blank">此程式的github</a><br><a href="https://colab.research.google.com/drive/1KFhAhgtUcVVS1nMKlZicMjzGQZWKA6sc" rel="external nofollow noopener noreferrer" target="_blank">此程式的notebook</a><br><a href="https://towardsdatascience.com/stock-prediction-in-python-b66555171a2" rel="external nofollow noopener noreferrer" target="_blank">國外Stocker文章</a><br><a href="https://github.com/WillKoehrsen/Data-Analysis/tree/master/stocker" rel="external nofollow noopener noreferrer" target="_blank">國外github</a><br><a href="https://github.com/facebook/prophet" rel="external nofollow noopener noreferrer" target="_blank">預言家github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多虧了python，用最先進的統計模型來預測股價，程式交易超簡單！&lt;br&gt;不用安裝程式，今天我們雲端寫code，適合完完全全的初學者！&lt;br&gt;非常多非常多的人都用 python 在開發程式，&lt;br&gt;因此，有很多高深數學軟體，都會有很多民間高手來實做，&lt;br&gt;而我們只要會用就好了！學python從這篇開始！&lt;br&gt;
    
    </summary>
    
      <category term="財經Python教學" scheme="https://www.finlab.tw/categories/%E8%B2%A1%E7%B6%93Python%E6%95%99%E5%AD%B8/"/>
    
    
      <category term="Machine Learning" scheme="https://www.finlab.tw/tags/Machine-Learning/"/>
    
      <category term="python" scheme="https://www.finlab.tw/tags/python/"/>
    
      <category term="程式交易" scheme="https://www.finlab.tw/tags/%E7%A8%8B%E5%BC%8F%E4%BA%A4%E6%98%93/"/>
    
      <category term="股價預測" scheme="https://www.finlab.tw/tags/%E8%82%A1%E5%83%B9%E9%A0%90%E6%B8%AC/"/>
    
  </entry>
  
</feed>
